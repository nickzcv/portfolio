{"ast":null,"code":"import _slicedToArray from \"/home/nick/Documents/GitHub/portfolio/client/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/home/nick/Documents/GitHub/portfolio/client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"/home/nick/Documents/GitHub/portfolio/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/home/nick/Documents/GitHub/portfolio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/nick/Documents/GitHub/portfolio/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Manager } from './utils/hammer';\nimport WheelInput from './inputs/wheel-input';\nimport MoveInput from './inputs/move-input';\nimport KeyInput from './inputs/key-input';\nimport ContextmenuInput from './inputs/contextmenu-input';\nimport EventRegistrar from './utils/event-registrar';\nimport { BASIC_EVENT_ALIASES, EVENT_RECOGNIZER_MAP, GESTURE_EVENT_ALIASES, RECOGNIZERS, RECOGNIZER_COMPATIBLE_MAP, RECOGNIZER_FALLBACK_MAP } from './constants';\nvar DEFAULT_OPTIONS = {\n  // event handlers\n  events: null,\n  // custom recognizers\n  recognizers: null,\n  recognizerOptions: {},\n  // Manager class\n  Manager: Manager,\n  // allow browser default touch action\n  // https://github.com/uber/react-map-gl/issues/506\n  touchAction: 'none',\n  tabIndex: 0\n}; // Unified API for subscribing to events about both\n// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')\n// and gestural input (e.g. 'click', 'tap', 'panstart').\n// Delegates gesture related event registration and handling to Hammer.js.\n\nvar EventManager = /*#__PURE__*/function () {\n  function EventManager() {\n    var _this = this;\n\n    var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var options = arguments.length > 1 ? arguments[1] : undefined;\n\n    _classCallCheck(this, EventManager);\n\n    /**\n     * Handle basic events using the 'hammer.input' Hammer.js API:\n     * Before running Recognizers, Hammer emits a 'hammer.input' event\n     * with the basic event info. This function emits all basic events\n     * aliased to the \"class\" of event received.\n     * See constants.BASIC_EVENT_CLASSES basic event class definitions.\n     */\n    this._onBasicInput = function (event) {\n      var srcEvent = event.srcEvent;\n      var alias = BASIC_EVENT_ALIASES[srcEvent.type];\n\n      if (alias) {\n        // fire all events aliased to srcEvent.type\n        _this.manager.emit(alias, event);\n      }\n    };\n    /**\n     * Handle events not supported by Hammer.js,\n     * and pipe back out through same (Hammer) channel used by other events.\n     */\n\n\n    this._onOtherEvent = function (event) {\n      // console.log('onotherevent', event.type, event)\n      _this.manager.emit(event.type, event);\n    };\n\n    this.options = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options);\n    this.events = new Map();\n    this.setElement(element); // Register all passed events.\n\n    var events = this.options.events;\n\n    if (events) {\n      this.on(events);\n    }\n  }\n\n  _createClass(EventManager, [{\n    key: \"getElement\",\n    value: function getElement() {\n      return this.element;\n    }\n  }, {\n    key: \"setElement\",\n    value: function setElement(element) {\n      var _this2 = this;\n\n      if (this.element) {\n        // unregister all events\n        this.destroy();\n      }\n\n      this.element = element;\n\n      if (!element) {\n        return;\n      }\n\n      var options = this.options;\n      var ManagerClass = options.Manager;\n      this.manager = new ManagerClass(element, {\n        touchAction: options.touchAction,\n        recognizers: options.recognizers || RECOGNIZERS\n      }).on('hammer.input', this._onBasicInput);\n\n      if (!options.recognizers) {\n        // Set default recognize withs\n        // http://hammerjs.github.io/recognize-with/\n        Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach(function (name) {\n          var recognizer = _this2.manager.get(name);\n\n          if (recognizer) {\n            RECOGNIZER_COMPATIBLE_MAP[name].forEach(function (otherName) {\n              recognizer.recognizeWith(otherName);\n            });\n          }\n        });\n      } // Set recognizer options\n\n\n      for (var recognizerName in options.recognizerOptions) {\n        var recognizer = this.manager.get(recognizerName);\n\n        if (recognizer) {\n          var recognizerOption = options.recognizerOptions[recognizerName]; // `enable` is managed by the event registrations\n\n          delete recognizerOption.enable;\n          recognizer.set(recognizerOption);\n        }\n      } // Handle events not handled by Hammer.js:\n      // - mouse wheel\n      // - pointer/touch/mouse move\n\n\n      this.wheelInput = new WheelInput(element, this._onOtherEvent, {\n        enable: false\n      });\n      this.moveInput = new MoveInput(element, this._onOtherEvent, {\n        enable: false\n      });\n      this.keyInput = new KeyInput(element, this._onOtherEvent, {\n        enable: false,\n        tabIndex: options.tabIndex\n      });\n      this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {\n        enable: false\n      }); // Register all existing events\n\n      var _iterator = _createForOfIteratorHelper(this.events),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              eventAlias = _step$value[0],\n              eventRegistrar = _step$value[1];\n\n          if (!eventRegistrar.isEmpty()) {\n            // Enable recognizer for this event.\n            this._toggleRecognizer(eventRegistrar.recognizerName, true);\n\n            this.manager.on(eventAlias, eventRegistrar.handleEvent);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    } // Tear down internal event management implementations.\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.element) {\n        // wheelInput etc. are created in setElement() and therefore\n        // cannot exist if there is no element\n        this.wheelInput.destroy();\n        this.moveInput.destroy();\n        this.keyInput.destroy();\n        this.contextmenuInput.destroy();\n        this.manager.destroy();\n        this.wheelInput = null;\n        this.moveInput = null;\n        this.keyInput = null;\n        this.contextmenuInput = null;\n        this.manager = null;\n        this.element = null;\n      }\n    }\n    /** Register an event handler function to be called on `event` */\n\n  }, {\n    key: \"on\",\n    value: function on(event, handler, opts) {\n      this._addEventHandler(event, handler, opts, false);\n    }\n  }, {\n    key: \"once\",\n    value: function once(event, handler, opts) {\n      this._addEventHandler(event, handler, opts, true);\n    }\n  }, {\n    key: \"watch\",\n    value: function watch(event, handler, opts) {\n      this._addEventHandler(event, handler, opts, false, true);\n    }\n  }, {\n    key: \"off\",\n    value: function off(event, handler) {\n      this._removeEventHandler(event, handler);\n    }\n    /*\n     * Enable/disable recognizer for the given event\n     */\n\n  }, {\n    key: \"_toggleRecognizer\",\n    value: function _toggleRecognizer(name, enabled) {\n      var manager = this.manager;\n\n      if (!manager) {\n        return;\n      }\n\n      var recognizer = manager.get(name); // @ts-ignore\n\n      if (recognizer && recognizer.options.enable !== enabled) {\n        recognizer.set({\n          enable: enabled\n        });\n        var fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name];\n\n        if (fallbackRecognizers && !this.options.recognizers) {\n          // Set default require failures\n          // http://hammerjs.github.io/require-failure/\n          fallbackRecognizers.forEach(function (otherName) {\n            var otherRecognizer = manager.get(otherName);\n\n            if (enabled) {\n              // Wait for this recognizer to fail\n              otherRecognizer.requireFailure(name);\n              /**\n               * This seems to be a bug in hammerjs:\n               * requireFailure() adds both ways\n               * dropRequireFailure() only drops one way\n               * https://github.com/hammerjs/hammer.js/blob/master/src/recognizerjs/\n                 recognizer-constructor.js#L136\n               */\n\n              recognizer.dropRequireFailure(otherName);\n            } else {\n              // Do not wait for this recognizer to fail\n              otherRecognizer.dropRequireFailure(name);\n            }\n          });\n        }\n      }\n\n      this.wheelInput.enableEventType(name, enabled);\n      this.moveInput.enableEventType(name, enabled);\n      this.keyInput.enableEventType(name, enabled);\n      this.contextmenuInput.enableEventType(name, enabled);\n    }\n    /**\n     * Process the event registration for a single event + handler.\n     */\n\n  }, {\n    key: \"_addEventHandler\",\n    value: function _addEventHandler(event, handler, opts, once, passive) {\n      if (typeof event !== 'string') {\n        // @ts-ignore\n        opts = handler; // If `event` is a map, call `on()` for each entry.\n\n        for (var eventName in event) {\n          this._addEventHandler(eventName, event[eventName], opts, once, passive);\n        }\n\n        return;\n      }\n\n      var manager = this.manager,\n          events = this.events; // Alias to a recognized gesture as necessary.\n\n      var eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n      var eventRegistrar = events.get(eventAlias);\n\n      if (!eventRegistrar) {\n        eventRegistrar = new EventRegistrar(this);\n        events.set(eventAlias, eventRegistrar); // Enable recognizer for this event.\n\n        eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias; // Listen to the event\n\n        if (manager) {\n          manager.on(eventAlias, eventRegistrar.handleEvent);\n        }\n      }\n\n      eventRegistrar.add(event, handler, opts, once, passive);\n\n      if (!eventRegistrar.isEmpty()) {\n        this._toggleRecognizer(eventRegistrar.recognizerName, true);\n      }\n    }\n    /**\n     * Process the event deregistration for a single event + handler.\n     */\n\n  }, {\n    key: \"_removeEventHandler\",\n    value: function _removeEventHandler(event, handler) {\n      if (typeof event !== 'string') {\n        // If `event` is a map, call `off()` for each entry.\n        for (var eventName in event) {\n          this._removeEventHandler(eventName, event[eventName]);\n        }\n\n        return;\n      }\n\n      var events = this.events; // Alias to a recognized gesture as necessary.\n\n      var eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n      var eventRegistrar = events.get(eventAlias);\n\n      if (!eventRegistrar) {\n        return;\n      }\n\n      eventRegistrar.remove(event, handler);\n\n      if (eventRegistrar.isEmpty()) {\n        var recognizerName = eventRegistrar.recognizerName; // Disable recognizer if no more handlers are attached to its events\n\n        var isRecognizerUsed = false;\n\n        var _iterator2 = _createForOfIteratorHelper(events.values()),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var eh = _step2.value;\n\n            if (eh.recognizerName === recognizerName && !eh.isEmpty()) {\n              isRecognizerUsed = true;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        if (!isRecognizerUsed) {\n          this._toggleRecognizer(recognizerName, false);\n        }\n      }\n    }\n  }]);\n\n  return EventManager;\n}();\n\nexport { EventManager as default };","map":{"version":3,"sources":["../../src/event-manager.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Manager } from './utils/hammer';\nimport WheelInput from './inputs/wheel-input';\nimport MoveInput from './inputs/move-input';\nimport KeyInput from './inputs/key-input';\nimport ContextmenuInput from './inputs/contextmenu-input';\nimport EventRegistrar from './utils/event-registrar';\nimport { BASIC_EVENT_ALIASES, EVENT_RECOGNIZER_MAP, GESTURE_EVENT_ALIASES, RECOGNIZERS, RECOGNIZER_COMPATIBLE_MAP, RECOGNIZER_FALLBACK_MAP } from './constants';\nconst DEFAULT_OPTIONS = {\n    // event handlers\n    events: null,\n    // custom recognizers\n    recognizers: null,\n    recognizerOptions: {},\n    // Manager class\n    Manager,\n    // allow browser default touch action\n    // https://github.com/uber/react-map-gl/issues/506\n    touchAction: 'none',\n    tabIndex: 0\n};\n// Unified API for subscribing to events about both\n// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')\n// and gestural input (e.g. 'click', 'tap', 'panstart').\n// Delegates gesture related event registration and handling to Hammer.js.\nexport default class EventManager {\n    constructor(element = null, options) {\n        /**\n         * Handle basic events using the 'hammer.input' Hammer.js API:\n         * Before running Recognizers, Hammer emits a 'hammer.input' event\n         * with the basic event info. This function emits all basic events\n         * aliased to the \"class\" of event received.\n         * See constants.BASIC_EVENT_CLASSES basic event class definitions.\n         */\n        this._onBasicInput = (event) => {\n            const { srcEvent } = event;\n            const alias = BASIC_EVENT_ALIASES[srcEvent.type];\n            if (alias) {\n                // fire all events aliased to srcEvent.type\n                this.manager.emit(alias, event);\n            }\n        };\n        /**\n         * Handle events not supported by Hammer.js,\n         * and pipe back out through same (Hammer) channel used by other events.\n         */\n        this._onOtherEvent = (event) => {\n            // console.log('onotherevent', event.type, event)\n            this.manager.emit(event.type, event);\n        };\n        this.options = { ...DEFAULT_OPTIONS, ...options };\n        this.events = new Map();\n        this.setElement(element);\n        // Register all passed events.\n        const { events } = this.options;\n        if (events) {\n            this.on(events);\n        }\n    }\n    getElement() {\n        return this.element;\n    }\n    setElement(element) {\n        if (this.element) {\n            // unregister all events\n            this.destroy();\n        }\n        this.element = element;\n        if (!element) {\n            return;\n        }\n        const { options } = this;\n        const ManagerClass = options.Manager;\n        this.manager = new ManagerClass(element, {\n            touchAction: options.touchAction,\n            recognizers: options.recognizers || RECOGNIZERS\n        }).on('hammer.input', this._onBasicInput);\n        if (!options.recognizers) {\n            // Set default recognize withs\n            // http://hammerjs.github.io/recognize-with/\n            Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach(name => {\n                const recognizer = this.manager.get(name);\n                if (recognizer) {\n                    RECOGNIZER_COMPATIBLE_MAP[name].forEach(otherName => {\n                        recognizer.recognizeWith(otherName);\n                    });\n                }\n            });\n        }\n        // Set recognizer options\n        for (const recognizerName in options.recognizerOptions) {\n            const recognizer = this.manager.get(recognizerName);\n            if (recognizer) {\n                const recognizerOption = options.recognizerOptions[recognizerName];\n                // `enable` is managed by the event registrations\n                delete recognizerOption.enable;\n                recognizer.set(recognizerOption);\n            }\n        }\n        // Handle events not handled by Hammer.js:\n        // - mouse wheel\n        // - pointer/touch/mouse move\n        this.wheelInput = new WheelInput(element, this._onOtherEvent, {\n            enable: false\n        });\n        this.moveInput = new MoveInput(element, this._onOtherEvent, {\n            enable: false\n        });\n        this.keyInput = new KeyInput(element, this._onOtherEvent, {\n            enable: false,\n            tabIndex: options.tabIndex\n        });\n        this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {\n            enable: false\n        });\n        // Register all existing events\n        for (const [eventAlias, eventRegistrar] of this.events) {\n            if (!eventRegistrar.isEmpty()) {\n                // Enable recognizer for this event.\n                this._toggleRecognizer(eventRegistrar.recognizerName, true);\n                this.manager.on(eventAlias, eventRegistrar.handleEvent);\n            }\n        }\n    }\n    // Tear down internal event management implementations.\n    destroy() {\n        if (this.element) {\n            // wheelInput etc. are created in setElement() and therefore\n            // cannot exist if there is no element\n            this.wheelInput.destroy();\n            this.moveInput.destroy();\n            this.keyInput.destroy();\n            this.contextmenuInput.destroy();\n            this.manager.destroy();\n            this.wheelInput = null;\n            this.moveInput = null;\n            this.keyInput = null;\n            this.contextmenuInput = null;\n            this.manager = null;\n            this.element = null;\n        }\n    }\n    /** Register an event handler function to be called on `event` */\n    on(event, handler, opts) {\n        this._addEventHandler(event, handler, opts, false);\n    }\n    once(event, handler, opts) {\n        this._addEventHandler(event, handler, opts, true);\n    }\n    watch(event, handler, opts) {\n        this._addEventHandler(event, handler, opts, false, true);\n    }\n    off(event, handler) {\n        this._removeEventHandler(event, handler);\n    }\n    /*\n     * Enable/disable recognizer for the given event\n     */\n    _toggleRecognizer(name, enabled) {\n        const { manager } = this;\n        if (!manager) {\n            return;\n        }\n        const recognizer = manager.get(name);\n        // @ts-ignore\n        if (recognizer && recognizer.options.enable !== enabled) {\n            recognizer.set({ enable: enabled });\n            const fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name];\n            if (fallbackRecognizers && !this.options.recognizers) {\n                // Set default require failures\n                // http://hammerjs.github.io/require-failure/\n                fallbackRecognizers.forEach(otherName => {\n                    const otherRecognizer = manager.get(otherName);\n                    if (enabled) {\n                        // Wait for this recognizer to fail\n                        otherRecognizer.requireFailure(name);\n                        /**\n                         * This seems to be a bug in hammerjs:\n                         * requireFailure() adds both ways\n                         * dropRequireFailure() only drops one way\n                         * https://github.com/hammerjs/hammer.js/blob/master/src/recognizerjs/\n                           recognizer-constructor.js#L136\n                         */\n                        recognizer.dropRequireFailure(otherName);\n                    }\n                    else {\n                        // Do not wait for this recognizer to fail\n                        otherRecognizer.dropRequireFailure(name);\n                    }\n                });\n            }\n        }\n        this.wheelInput.enableEventType(name, enabled);\n        this.moveInput.enableEventType(name, enabled);\n        this.keyInput.enableEventType(name, enabled);\n        this.contextmenuInput.enableEventType(name, enabled);\n    }\n    /**\n     * Process the event registration for a single event + handler.\n     */\n    _addEventHandler(event, handler, opts, once, passive) {\n        if (typeof event !== 'string') {\n            // @ts-ignore\n            opts = handler;\n            // If `event` is a map, call `on()` for each entry.\n            for (const eventName in event) {\n                this._addEventHandler(eventName, event[eventName], opts, once, passive);\n            }\n            return;\n        }\n        const { manager, events } = this;\n        // Alias to a recognized gesture as necessary.\n        const eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n        let eventRegistrar = events.get(eventAlias);\n        if (!eventRegistrar) {\n            eventRegistrar = new EventRegistrar(this);\n            events.set(eventAlias, eventRegistrar);\n            // Enable recognizer for this event.\n            eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;\n            // Listen to the event\n            if (manager) {\n                manager.on(eventAlias, eventRegistrar.handleEvent);\n            }\n        }\n        eventRegistrar.add(event, handler, opts, once, passive);\n        if (!eventRegistrar.isEmpty()) {\n            this._toggleRecognizer(eventRegistrar.recognizerName, true);\n        }\n    }\n    /**\n     * Process the event deregistration for a single event + handler.\n     */\n    _removeEventHandler(event, handler) {\n        if (typeof event !== 'string') {\n            // If `event` is a map, call `off()` for each entry.\n            for (const eventName in event) {\n                this._removeEventHandler(eventName, event[eventName]);\n            }\n            return;\n        }\n        const { events } = this;\n        // Alias to a recognized gesture as necessary.\n        const eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n        const eventRegistrar = events.get(eventAlias);\n        if (!eventRegistrar) {\n            return;\n        }\n        eventRegistrar.remove(event, handler);\n        if (eventRegistrar.isEmpty()) {\n            const { recognizerName } = eventRegistrar;\n            // Disable recognizer if no more handlers are attached to its events\n            let isRecognizerUsed = false;\n            for (const eh of events.values()) {\n                if (eh.recognizerName === recognizerName && !eh.isEmpty()) {\n                    isRecognizerUsed = true;\n                    break;\n                }\n            }\n            if (!isRecognizerUsed) {\n                this._toggleRecognizer(recognizerName, false);\n            }\n        }\n    }\n}\n//# sourceMappingURL=event-manager.js.map"]},"metadata":{},"sourceType":"module"}