{"ast":null,"code":"import { Manager } from './utils/hammer';\nimport WheelInput from './inputs/wheel-input';\nimport MoveInput from './inputs/move-input';\nimport KeyInput from './inputs/key-input';\nimport ContextmenuInput from './inputs/contextmenu-input';\nimport EventRegistrar from './utils/event-registrar';\nimport { BASIC_EVENT_ALIASES, EVENT_RECOGNIZER_MAP, GESTURE_EVENT_ALIASES, RECOGNIZERS, RECOGNIZER_COMPATIBLE_MAP, RECOGNIZER_FALLBACK_MAP } from './constants';\nconst DEFAULT_OPTIONS = {\n  // event handlers\n  events: null,\n  // custom recognizers\n  recognizers: null,\n  recognizerOptions: {},\n  // Manager class\n  Manager,\n  // allow browser default touch action\n  // https://github.com/uber/react-map-gl/issues/506\n  touchAction: 'none',\n  tabIndex: 0\n}; // Unified API for subscribing to events about both\n// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')\n// and gestural input (e.g. 'click', 'tap', 'panstart').\n// Delegates gesture related event registration and handling to Hammer.js.\n\nexport default class EventManager {\n  constructor() {\n    let element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let options = arguments.length > 1 ? arguments[1] : undefined;\n\n    /**\n     * Handle basic events using the 'hammer.input' Hammer.js API:\n     * Before running Recognizers, Hammer emits a 'hammer.input' event\n     * with the basic event info. This function emits all basic events\n     * aliased to the \"class\" of event received.\n     * See constants.BASIC_EVENT_CLASSES basic event class definitions.\n     */\n    this._onBasicInput = event => {\n      const {\n        srcEvent\n      } = event;\n      const alias = BASIC_EVENT_ALIASES[srcEvent.type];\n\n      if (alias) {\n        // fire all events aliased to srcEvent.type\n        this.manager.emit(alias, event);\n      }\n    };\n    /**\n     * Handle events not supported by Hammer.js,\n     * and pipe back out through same (Hammer) channel used by other events.\n     */\n\n\n    this._onOtherEvent = event => {\n      // console.log('onotherevent', event.type, event)\n      this.manager.emit(event.type, event);\n    };\n\n    this.options = { ...DEFAULT_OPTIONS,\n      ...options\n    };\n    this.events = new Map();\n    this.setElement(element); // Register all passed events.\n\n    const {\n      events\n    } = this.options;\n\n    if (events) {\n      this.on(events);\n    }\n  }\n\n  getElement() {\n    return this.element;\n  }\n\n  setElement(element) {\n    if (this.element) {\n      // unregister all events\n      this.destroy();\n    }\n\n    this.element = element;\n\n    if (!element) {\n      return;\n    }\n\n    const {\n      options\n    } = this;\n    const ManagerClass = options.Manager;\n    this.manager = new ManagerClass(element, {\n      touchAction: options.touchAction,\n      recognizers: options.recognizers || RECOGNIZERS\n    }).on('hammer.input', this._onBasicInput);\n\n    if (!options.recognizers) {\n      // Set default recognize withs\n      // http://hammerjs.github.io/recognize-with/\n      Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach(name => {\n        const recognizer = this.manager.get(name);\n\n        if (recognizer) {\n          RECOGNIZER_COMPATIBLE_MAP[name].forEach(otherName => {\n            recognizer.recognizeWith(otherName);\n          });\n        }\n      });\n    } // Set recognizer options\n\n\n    for (const recognizerName in options.recognizerOptions) {\n      const recognizer = this.manager.get(recognizerName);\n\n      if (recognizer) {\n        const recognizerOption = options.recognizerOptions[recognizerName]; // `enable` is managed by the event registrations\n\n        delete recognizerOption.enable;\n        recognizer.set(recognizerOption);\n      }\n    } // Handle events not handled by Hammer.js:\n    // - mouse wheel\n    // - pointer/touch/mouse move\n\n\n    this.wheelInput = new WheelInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.moveInput = new MoveInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.keyInput = new KeyInput(element, this._onOtherEvent, {\n      enable: false,\n      tabIndex: options.tabIndex\n    });\n    this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {\n      enable: false\n    }); // Register all existing events\n\n    for (const [eventAlias, eventRegistrar] of this.events) {\n      if (!eventRegistrar.isEmpty()) {\n        // Enable recognizer for this event.\n        this._toggleRecognizer(eventRegistrar.recognizerName, true);\n\n        this.manager.on(eventAlias, eventRegistrar.handleEvent);\n      }\n    }\n  } // Tear down internal event management implementations.\n\n\n  destroy() {\n    if (this.element) {\n      // wheelInput etc. are created in setElement() and therefore\n      // cannot exist if there is no element\n      this.wheelInput.destroy();\n      this.moveInput.destroy();\n      this.keyInput.destroy();\n      this.contextmenuInput.destroy();\n      this.manager.destroy();\n      this.wheelInput = null;\n      this.moveInput = null;\n      this.keyInput = null;\n      this.contextmenuInput = null;\n      this.manager = null;\n      this.element = null;\n    }\n  }\n  /** Register an event handler function to be called on `event` */\n\n\n  on(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, false);\n  }\n\n  once(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, true);\n  }\n\n  watch(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, false, true);\n  }\n\n  off(event, handler) {\n    this._removeEventHandler(event, handler);\n  }\n  /*\n   * Enable/disable recognizer for the given event\n   */\n\n\n  _toggleRecognizer(name, enabled) {\n    const {\n      manager\n    } = this;\n\n    if (!manager) {\n      return;\n    }\n\n    const recognizer = manager.get(name); // @ts-ignore\n\n    if (recognizer && recognizer.options.enable !== enabled) {\n      recognizer.set({\n        enable: enabled\n      });\n      const fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name];\n\n      if (fallbackRecognizers && !this.options.recognizers) {\n        // Set default require failures\n        // http://hammerjs.github.io/require-failure/\n        fallbackRecognizers.forEach(otherName => {\n          const otherRecognizer = manager.get(otherName);\n\n          if (enabled) {\n            // Wait for this recognizer to fail\n            otherRecognizer.requireFailure(name);\n            /**\n             * This seems to be a bug in hammerjs:\n             * requireFailure() adds both ways\n             * dropRequireFailure() only drops one way\n             * https://github.com/hammerjs/hammer.js/blob/master/src/recognizerjs/\n               recognizer-constructor.js#L136\n             */\n\n            recognizer.dropRequireFailure(otherName);\n          } else {\n            // Do not wait for this recognizer to fail\n            otherRecognizer.dropRequireFailure(name);\n          }\n        });\n      }\n    }\n\n    this.wheelInput.enableEventType(name, enabled);\n    this.moveInput.enableEventType(name, enabled);\n    this.keyInput.enableEventType(name, enabled);\n    this.contextmenuInput.enableEventType(name, enabled);\n  }\n  /**\n   * Process the event registration for a single event + handler.\n   */\n\n\n  _addEventHandler(event, handler, opts, once, passive) {\n    if (typeof event !== 'string') {\n      // @ts-ignore\n      opts = handler; // If `event` is a map, call `on()` for each entry.\n\n      for (const eventName in event) {\n        this._addEventHandler(eventName, event[eventName], opts, once, passive);\n      }\n\n      return;\n    }\n\n    const {\n      manager,\n      events\n    } = this; // Alias to a recognized gesture as necessary.\n\n    const eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n    let eventRegistrar = events.get(eventAlias);\n\n    if (!eventRegistrar) {\n      eventRegistrar = new EventRegistrar(this);\n      events.set(eventAlias, eventRegistrar); // Enable recognizer for this event.\n\n      eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias; // Listen to the event\n\n      if (manager) {\n        manager.on(eventAlias, eventRegistrar.handleEvent);\n      }\n    }\n\n    eventRegistrar.add(event, handler, opts, once, passive);\n\n    if (!eventRegistrar.isEmpty()) {\n      this._toggleRecognizer(eventRegistrar.recognizerName, true);\n    }\n  }\n  /**\n   * Process the event deregistration for a single event + handler.\n   */\n\n\n  _removeEventHandler(event, handler) {\n    if (typeof event !== 'string') {\n      // If `event` is a map, call `off()` for each entry.\n      for (const eventName in event) {\n        this._removeEventHandler(eventName, event[eventName]);\n      }\n\n      return;\n    }\n\n    const {\n      events\n    } = this; // Alias to a recognized gesture as necessary.\n\n    const eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n    const eventRegistrar = events.get(eventAlias);\n\n    if (!eventRegistrar) {\n      return;\n    }\n\n    eventRegistrar.remove(event, handler);\n\n    if (eventRegistrar.isEmpty()) {\n      const {\n        recognizerName\n      } = eventRegistrar; // Disable recognizer if no more handlers are attached to its events\n\n      let isRecognizerUsed = false;\n\n      for (const eh of events.values()) {\n        if (eh.recognizerName === recognizerName && !eh.isEmpty()) {\n          isRecognizerUsed = true;\n          break;\n        }\n      }\n\n      if (!isRecognizerUsed) {\n        this._toggleRecognizer(recognizerName, false);\n      }\n    }\n  }\n\n}","map":{"version":3,"sources":["../../src/event-manager.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Manager } from './utils/hammer';\nimport WheelInput from './inputs/wheel-input';\nimport MoveInput from './inputs/move-input';\nimport KeyInput from './inputs/key-input';\nimport ContextmenuInput from './inputs/contextmenu-input';\nimport EventRegistrar from './utils/event-registrar';\nimport { BASIC_EVENT_ALIASES, EVENT_RECOGNIZER_MAP, GESTURE_EVENT_ALIASES, RECOGNIZERS, RECOGNIZER_COMPATIBLE_MAP, RECOGNIZER_FALLBACK_MAP } from './constants';\nconst DEFAULT_OPTIONS = {\n    // event handlers\n    events: null,\n    // custom recognizers\n    recognizers: null,\n    recognizerOptions: {},\n    // Manager class\n    Manager,\n    // allow browser default touch action\n    // https://github.com/uber/react-map-gl/issues/506\n    touchAction: 'none',\n    tabIndex: 0\n};\n// Unified API for subscribing to events about both\n// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')\n// and gestural input (e.g. 'click', 'tap', 'panstart').\n// Delegates gesture related event registration and handling to Hammer.js.\nexport default class EventManager {\n    constructor(element = null, options) {\n        /**\n         * Handle basic events using the 'hammer.input' Hammer.js API:\n         * Before running Recognizers, Hammer emits a 'hammer.input' event\n         * with the basic event info. This function emits all basic events\n         * aliased to the \"class\" of event received.\n         * See constants.BASIC_EVENT_CLASSES basic event class definitions.\n         */\n        this._onBasicInput = (event) => {\n            const { srcEvent } = event;\n            const alias = BASIC_EVENT_ALIASES[srcEvent.type];\n            if (alias) {\n                // fire all events aliased to srcEvent.type\n                this.manager.emit(alias, event);\n            }\n        };\n        /**\n         * Handle events not supported by Hammer.js,\n         * and pipe back out through same (Hammer) channel used by other events.\n         */\n        this._onOtherEvent = (event) => {\n            // console.log('onotherevent', event.type, event)\n            this.manager.emit(event.type, event);\n        };\n        this.options = { ...DEFAULT_OPTIONS, ...options };\n        this.events = new Map();\n        this.setElement(element);\n        // Register all passed events.\n        const { events } = this.options;\n        if (events) {\n            this.on(events);\n        }\n    }\n    getElement() {\n        return this.element;\n    }\n    setElement(element) {\n        if (this.element) {\n            // unregister all events\n            this.destroy();\n        }\n        this.element = element;\n        if (!element) {\n            return;\n        }\n        const { options } = this;\n        const ManagerClass = options.Manager;\n        this.manager = new ManagerClass(element, {\n            touchAction: options.touchAction,\n            recognizers: options.recognizers || RECOGNIZERS\n        }).on('hammer.input', this._onBasicInput);\n        if (!options.recognizers) {\n            // Set default recognize withs\n            // http://hammerjs.github.io/recognize-with/\n            Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach(name => {\n                const recognizer = this.manager.get(name);\n                if (recognizer) {\n                    RECOGNIZER_COMPATIBLE_MAP[name].forEach(otherName => {\n                        recognizer.recognizeWith(otherName);\n                    });\n                }\n            });\n        }\n        // Set recognizer options\n        for (const recognizerName in options.recognizerOptions) {\n            const recognizer = this.manager.get(recognizerName);\n            if (recognizer) {\n                const recognizerOption = options.recognizerOptions[recognizerName];\n                // `enable` is managed by the event registrations\n                delete recognizerOption.enable;\n                recognizer.set(recognizerOption);\n            }\n        }\n        // Handle events not handled by Hammer.js:\n        // - mouse wheel\n        // - pointer/touch/mouse move\n        this.wheelInput = new WheelInput(element, this._onOtherEvent, {\n            enable: false\n        });\n        this.moveInput = new MoveInput(element, this._onOtherEvent, {\n            enable: false\n        });\n        this.keyInput = new KeyInput(element, this._onOtherEvent, {\n            enable: false,\n            tabIndex: options.tabIndex\n        });\n        this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {\n            enable: false\n        });\n        // Register all existing events\n        for (const [eventAlias, eventRegistrar] of this.events) {\n            if (!eventRegistrar.isEmpty()) {\n                // Enable recognizer for this event.\n                this._toggleRecognizer(eventRegistrar.recognizerName, true);\n                this.manager.on(eventAlias, eventRegistrar.handleEvent);\n            }\n        }\n    }\n    // Tear down internal event management implementations.\n    destroy() {\n        if (this.element) {\n            // wheelInput etc. are created in setElement() and therefore\n            // cannot exist if there is no element\n            this.wheelInput.destroy();\n            this.moveInput.destroy();\n            this.keyInput.destroy();\n            this.contextmenuInput.destroy();\n            this.manager.destroy();\n            this.wheelInput = null;\n            this.moveInput = null;\n            this.keyInput = null;\n            this.contextmenuInput = null;\n            this.manager = null;\n            this.element = null;\n        }\n    }\n    /** Register an event handler function to be called on `event` */\n    on(event, handler, opts) {\n        this._addEventHandler(event, handler, opts, false);\n    }\n    once(event, handler, opts) {\n        this._addEventHandler(event, handler, opts, true);\n    }\n    watch(event, handler, opts) {\n        this._addEventHandler(event, handler, opts, false, true);\n    }\n    off(event, handler) {\n        this._removeEventHandler(event, handler);\n    }\n    /*\n     * Enable/disable recognizer for the given event\n     */\n    _toggleRecognizer(name, enabled) {\n        const { manager } = this;\n        if (!manager) {\n            return;\n        }\n        const recognizer = manager.get(name);\n        // @ts-ignore\n        if (recognizer && recognizer.options.enable !== enabled) {\n            recognizer.set({ enable: enabled });\n            const fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name];\n            if (fallbackRecognizers && !this.options.recognizers) {\n                // Set default require failures\n                // http://hammerjs.github.io/require-failure/\n                fallbackRecognizers.forEach(otherName => {\n                    const otherRecognizer = manager.get(otherName);\n                    if (enabled) {\n                        // Wait for this recognizer to fail\n                        otherRecognizer.requireFailure(name);\n                        /**\n                         * This seems to be a bug in hammerjs:\n                         * requireFailure() adds both ways\n                         * dropRequireFailure() only drops one way\n                         * https://github.com/hammerjs/hammer.js/blob/master/src/recognizerjs/\n                           recognizer-constructor.js#L136\n                         */\n                        recognizer.dropRequireFailure(otherName);\n                    }\n                    else {\n                        // Do not wait for this recognizer to fail\n                        otherRecognizer.dropRequireFailure(name);\n                    }\n                });\n            }\n        }\n        this.wheelInput.enableEventType(name, enabled);\n        this.moveInput.enableEventType(name, enabled);\n        this.keyInput.enableEventType(name, enabled);\n        this.contextmenuInput.enableEventType(name, enabled);\n    }\n    /**\n     * Process the event registration for a single event + handler.\n     */\n    _addEventHandler(event, handler, opts, once, passive) {\n        if (typeof event !== 'string') {\n            // @ts-ignore\n            opts = handler;\n            // If `event` is a map, call `on()` for each entry.\n            for (const eventName in event) {\n                this._addEventHandler(eventName, event[eventName], opts, once, passive);\n            }\n            return;\n        }\n        const { manager, events } = this;\n        // Alias to a recognized gesture as necessary.\n        const eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n        let eventRegistrar = events.get(eventAlias);\n        if (!eventRegistrar) {\n            eventRegistrar = new EventRegistrar(this);\n            events.set(eventAlias, eventRegistrar);\n            // Enable recognizer for this event.\n            eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;\n            // Listen to the event\n            if (manager) {\n                manager.on(eventAlias, eventRegistrar.handleEvent);\n            }\n        }\n        eventRegistrar.add(event, handler, opts, once, passive);\n        if (!eventRegistrar.isEmpty()) {\n            this._toggleRecognizer(eventRegistrar.recognizerName, true);\n        }\n    }\n    /**\n     * Process the event deregistration for a single event + handler.\n     */\n    _removeEventHandler(event, handler) {\n        if (typeof event !== 'string') {\n            // If `event` is a map, call `off()` for each entry.\n            for (const eventName in event) {\n                this._removeEventHandler(eventName, event[eventName]);\n            }\n            return;\n        }\n        const { events } = this;\n        // Alias to a recognized gesture as necessary.\n        const eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n        const eventRegistrar = events.get(eventAlias);\n        if (!eventRegistrar) {\n            return;\n        }\n        eventRegistrar.remove(event, handler);\n        if (eventRegistrar.isEmpty()) {\n            const { recognizerName } = eventRegistrar;\n            // Disable recognizer if no more handlers are attached to its events\n            let isRecognizerUsed = false;\n            for (const eh of events.values()) {\n                if (eh.recognizerName === recognizerName && !eh.isEmpty()) {\n                    isRecognizerUsed = true;\n                    break;\n                }\n            }\n            if (!isRecognizerUsed) {\n                this._toggleRecognizer(recognizerName, false);\n            }\n        }\n    }\n}\n//# sourceMappingURL=event-manager.js.map"]},"metadata":{},"sourceType":"module"}