{"ast":null,"code":"import _objectSpread from \"/home/nick/Documents/GitHub/portfolio/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/home/nick/Documents/GitHub/portfolio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/nick/Documents/GitHub/portfolio/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { whichButtons, getOffsetPosition } from './event-utils';\nvar DEFAULT_OPTIONS = {\n  srcElement: 'root',\n  priority: 0\n};\n\nvar EventRegistrar = /*#__PURE__*/function () {\n  function EventRegistrar(eventManager) {\n    var _this = this;\n\n    _classCallCheck(this, EventRegistrar);\n\n    /**\n     * Handles hammerjs event\n     */\n    this.handleEvent = function (event) {\n      if (_this.isEmpty()) {\n        return;\n      }\n\n      var mjolnirEvent = _this._normalizeEvent(event);\n\n      var target = event.srcEvent.target;\n\n      while (target && target !== mjolnirEvent.rootElement) {\n        _this._emit(mjolnirEvent, target);\n\n        if (mjolnirEvent.handled) {\n          return;\n        }\n\n        target = target.parentNode;\n      }\n\n      _this._emit(mjolnirEvent, 'root');\n    };\n\n    this.eventManager = eventManager;\n    this.handlers = []; // Element -> handler map\n\n    this.handlersByElement = new Map();\n    this._active = false;\n  } // Returns true if there are no non-passive handlers\n\n\n  _createClass(EventRegistrar, [{\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return !this._active;\n    }\n  }, {\n    key: \"add\",\n    value: function add(type, handler, options) {\n      var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var passive = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var handlers = this.handlers,\n          handlersByElement = this.handlersByElement;\n      var opts = DEFAULT_OPTIONS;\n\n      if (typeof options === 'string' || options && options.addEventListener) {\n        // is DOM element, backward compatibility\n        // @ts-ignore\n        opts = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS), {}, {\n          srcElement: options\n        });\n      } else if (options) {\n        opts = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options);\n      }\n\n      var entries = handlersByElement.get(opts.srcElement);\n\n      if (!entries) {\n        entries = [];\n        handlersByElement.set(opts.srcElement, entries);\n      }\n\n      var entry = {\n        type: type,\n        handler: handler,\n        srcElement: opts.srcElement,\n        priority: opts.priority\n      };\n\n      if (once) {\n        entry.once = true;\n      }\n\n      if (passive) {\n        entry.passive = true;\n      }\n\n      handlers.push(entry);\n      this._active = this._active || !entry.passive; // Sort handlers by descending priority\n      // Handlers with the same priority are excuted in the order of registration\n\n      var insertPosition = entries.length - 1;\n\n      while (insertPosition >= 0) {\n        if (entries[insertPosition].priority >= entry.priority) {\n          break;\n        }\n\n        insertPosition--;\n      }\n\n      entries.splice(insertPosition + 1, 0, entry);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(type, handler) {\n      var handlers = this.handlers,\n          handlersByElement = this.handlersByElement;\n\n      for (var i = handlers.length - 1; i >= 0; i--) {\n        var entry = handlers[i];\n\n        if (entry.type === type && entry.handler === handler) {\n          handlers.splice(i, 1);\n          var entries = handlersByElement.get(entry.srcElement);\n          entries.splice(entries.indexOf(entry), 1);\n\n          if (entries.length === 0) {\n            handlersByElement.delete(entry.srcElement);\n          }\n        }\n      }\n\n      this._active = handlers.some(function (entry) {\n        return !entry.passive;\n      });\n    }\n    /**\n     * Invoke handlers on a particular element\n     */\n\n  }, {\n    key: \"_emit\",\n    value: function _emit(event, srcElement) {\n      var entries = this.handlersByElement.get(srcElement);\n\n      if (entries) {\n        var immediatePropagationStopped = false; // Prevents the current event from bubbling up\n\n        var stopPropagation = function stopPropagation() {\n          event.handled = true;\n        }; // Prevent any remaining listeners from being called\n\n\n        var stopImmediatePropagation = function stopImmediatePropagation() {\n          event.handled = true;\n          immediatePropagationStopped = true;\n        };\n\n        var entriesToRemove = [];\n\n        for (var i = 0; i < entries.length; i++) {\n          var _entries$i = entries[i],\n              type = _entries$i.type,\n              handler = _entries$i.handler,\n              once = _entries$i.once;\n          handler(_objectSpread(_objectSpread({}, event), {}, {\n            // @ts-ignore\n            type: type,\n            stopPropagation: stopPropagation,\n            stopImmediatePropagation: stopImmediatePropagation\n          }));\n\n          if (once) {\n            entriesToRemove.push(entries[i]);\n          }\n\n          if (immediatePropagationStopped) {\n            break;\n          }\n        }\n\n        for (var _i = 0; _i < entriesToRemove.length; _i++) {\n          var _entriesToRemove$_i = entriesToRemove[_i],\n              _type = _entriesToRemove$_i.type,\n              _handler = _entriesToRemove$_i.handler;\n          this.remove(_type, _handler);\n        }\n      }\n    }\n    /**\n     * Normalizes hammerjs and custom events to have predictable fields.\n     */\n\n  }, {\n    key: \"_normalizeEvent\",\n    value: function _normalizeEvent(event) {\n      var rootElement = this.eventManager.getElement();\n      return _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, event), whichButtons(event)), getOffsetPosition(event, rootElement)), {}, {\n        preventDefault: function preventDefault() {\n          event.srcEvent.preventDefault();\n        },\n        stopImmediatePropagation: null,\n        stopPropagation: null,\n        handled: false,\n        rootElement: rootElement\n      });\n    }\n  }]);\n\n  return EventRegistrar;\n}();\n\nexport { EventRegistrar as default };","map":{"version":3,"sources":["../../../src/utils/event-registrar.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { whichButtons, getOffsetPosition } from './event-utils';\nconst DEFAULT_OPTIONS = {\n    srcElement: 'root',\n    priority: 0\n};\nexport default class EventRegistrar {\n    constructor(eventManager) {\n        /**\n         * Handles hammerjs event\n         */\n        this.handleEvent = (event) => {\n            if (this.isEmpty()) {\n                return;\n            }\n            const mjolnirEvent = this._normalizeEvent(event);\n            let target = event.srcEvent.target;\n            while (target && target !== mjolnirEvent.rootElement) {\n                this._emit(mjolnirEvent, target);\n                if (mjolnirEvent.handled) {\n                    return;\n                }\n                target = target.parentNode;\n            }\n            this._emit(mjolnirEvent, 'root');\n        };\n        this.eventManager = eventManager;\n        this.handlers = [];\n        // Element -> handler map\n        this.handlersByElement = new Map();\n        this._active = false;\n    }\n    // Returns true if there are no non-passive handlers\n    isEmpty() {\n        return !this._active;\n    }\n    add(type, handler, options, once = false, passive = false) {\n        const { handlers, handlersByElement } = this;\n        let opts = DEFAULT_OPTIONS;\n        if (typeof options === 'string' || (options && options.addEventListener)) {\n            // is DOM element, backward compatibility\n            // @ts-ignore\n            opts = { ...DEFAULT_OPTIONS, srcElement: options };\n        }\n        else if (options) {\n            opts = { ...DEFAULT_OPTIONS, ...options };\n        }\n        let entries = handlersByElement.get(opts.srcElement);\n        if (!entries) {\n            entries = [];\n            handlersByElement.set(opts.srcElement, entries);\n        }\n        const entry = {\n            type,\n            handler,\n            srcElement: opts.srcElement,\n            priority: opts.priority\n        };\n        if (once) {\n            entry.once = true;\n        }\n        if (passive) {\n            entry.passive = true;\n        }\n        handlers.push(entry);\n        this._active = this._active || !entry.passive;\n        // Sort handlers by descending priority\n        // Handlers with the same priority are excuted in the order of registration\n        let insertPosition = entries.length - 1;\n        while (insertPosition >= 0) {\n            if (entries[insertPosition].priority >= entry.priority) {\n                break;\n            }\n            insertPosition--;\n        }\n        entries.splice(insertPosition + 1, 0, entry);\n    }\n    remove(type, handler) {\n        const { handlers, handlersByElement } = this;\n        for (let i = handlers.length - 1; i >= 0; i--) {\n            const entry = handlers[i];\n            if (entry.type === type && entry.handler === handler) {\n                handlers.splice(i, 1);\n                const entries = handlersByElement.get(entry.srcElement);\n                entries.splice(entries.indexOf(entry), 1);\n                if (entries.length === 0) {\n                    handlersByElement.delete(entry.srcElement);\n                }\n            }\n        }\n        this._active = handlers.some(entry => !entry.passive);\n    }\n    /**\n     * Invoke handlers on a particular element\n     */\n    _emit(event, srcElement) {\n        const entries = this.handlersByElement.get(srcElement);\n        if (entries) {\n            let immediatePropagationStopped = false;\n            // Prevents the current event from bubbling up\n            const stopPropagation = () => {\n                event.handled = true;\n            };\n            // Prevent any remaining listeners from being called\n            const stopImmediatePropagation = () => {\n                event.handled = true;\n                immediatePropagationStopped = true;\n            };\n            const entriesToRemove = [];\n            for (let i = 0; i < entries.length; i++) {\n                const { type, handler, once } = entries[i];\n                handler({\n                    ...event,\n                    // @ts-ignore\n                    type,\n                    stopPropagation,\n                    stopImmediatePropagation\n                });\n                if (once) {\n                    entriesToRemove.push(entries[i]);\n                }\n                if (immediatePropagationStopped) {\n                    break;\n                }\n            }\n            for (let i = 0; i < entriesToRemove.length; i++) {\n                const { type, handler } = entriesToRemove[i];\n                this.remove(type, handler);\n            }\n        }\n    }\n    /**\n     * Normalizes hammerjs and custom events to have predictable fields.\n     */\n    _normalizeEvent(event) {\n        const rootElement = this.eventManager.getElement();\n        return {\n            ...event,\n            ...whichButtons(event),\n            ...getOffsetPosition(event, rootElement),\n            preventDefault: () => {\n                event.srcEvent.preventDefault();\n            },\n            stopImmediatePropagation: null,\n            stopPropagation: null,\n            handled: false,\n            rootElement\n        };\n    }\n}\n//# sourceMappingURL=event-registrar.js.map"]},"metadata":{},"sourceType":"module"}