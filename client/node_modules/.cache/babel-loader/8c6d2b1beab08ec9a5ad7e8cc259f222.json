{"ast":null,"code":"import assert from './assert';\nimport { log2, clamp } from './math-utils';\nimport { MAX_LATITUDE, lngLatToWorld, worldToLngLat } from './web-mercator-utils';\nexport default function fitBounds(options) {\n  const {\n    width,\n    height,\n    bounds,\n    minExtent = 0,\n    maxZoom = 24,\n    offset = [0, 0]\n  } = options;\n  const [[west, south], [east, north]] = bounds;\n  const padding = getPaddingObject(options.padding);\n  const nw = lngLatToWorld([west, clamp(north, -MAX_LATITUDE, MAX_LATITUDE)]);\n  const se = lngLatToWorld([east, clamp(south, -MAX_LATITUDE, MAX_LATITUDE)]);\n  const size = [Math.max(Math.abs(se[0] - nw[0]), minExtent), Math.max(Math.abs(se[1] - nw[1]), minExtent)];\n  const targetSize = [width - padding.left - padding.right - Math.abs(offset[0]) * 2, height - padding.top - padding.bottom - Math.abs(offset[1]) * 2];\n  assert(targetSize[0] > 0 && targetSize[1] > 0);\n  const scaleX = targetSize[0] / size[0];\n  const scaleY = targetSize[1] / size[1];\n  const offsetX = (padding.right - padding.left) / 2 / scaleX;\n  const offsetY = (padding.top - padding.bottom) / 2 / scaleY;\n  const center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];\n  const centerLngLat = worldToLngLat(center);\n  const zoom = Math.min(maxZoom, log2(Math.abs(Math.min(scaleX, scaleY))));\n  assert(Number.isFinite(zoom));\n  return {\n    longitude: centerLngLat[0],\n    latitude: centerLngLat[1],\n    zoom\n  };\n}\n\nfunction getPaddingObject() {\n  let padding = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n  if (typeof padding === 'number') {\n    return {\n      top: padding,\n      bottom: padding,\n      left: padding,\n      right: padding\n    };\n  }\n\n  assert(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));\n  return padding;\n}","map":{"version":3,"sources":["../../src/fit-bounds.ts"],"names":["minExtent","maxZoom","offset","padding","getPaddingObject","options","nw","lngLatToWorld","clamp","se","size","Math","targetSize","width","height","assert","scaleX","scaleY","offsetX","offsetY","center","centerLngLat","worldToLngLat","zoom","log2","Number","longitude","latitude","top","bottom","left","right"],"mappings":"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","sourcesContent":["import assert from './assert';\nimport {log2, clamp} from './math-utils';\nimport {MAX_LATITUDE, lngLatToWorld, worldToLngLat} from './web-mercator-utils';\n\n/**\n * Options for fitBounds\n * @param width - viewport width\n * @param height - viewport height\n * @param bounds - [[lon, lat], [lon, lat]]\n * @param minExtent - The width/height of the bounded area will never be smaller than this\n * @param padding - The amount of padding in pixels\n *  to add to the given bounds. Can also be an object with top, bottom, left and right\n *  properties defining the padding.\n * @param options.offset= - The center of the given bounds relative to the map's center,\n */\nexport type FitBoundsOptions = {\n  width: number;\n  height: number;\n  bounds: [[number, number], [number, number]];\n  minExtent?: number; // 0.01 would be about 1000 meters (degree is ~110KM)\n  maxZoom?: number; // ~x4,000,000 => About 10 meter extents\n  // options\n  padding?: number | Padding;\n  offset?: number[];\n};\n\n/**\n * An object describing the padding to add to the bounds.\n * @property top - Padding from top in pixels to add to the given bounds\n * @property bottom - Padding from bottom in pixels to add to the given bounds\n * @property left - Padding from left in pixels to add to the given bounds\n * @property right - Padding from right in pixels to add to the given bounds\n */\nexport type Padding = {\n  top: number;\n  bottom: number;\n  left: number;\n  right: number;\n};\n\ntype ViewportProps = {\n  longitude: number;\n  latitude: number;\n  zoom: number;\n};\n\n/**\n * Returns map settings {latitude, longitude, zoom}\n * that will contain the provided corners within the provided width.\n *\n * > _Note: Only supports non-perspective mode._\n *\n * @param options fit bounds parameters\n * @returns - latitude, longitude and zoom\n */\nexport default function fitBounds(options: FitBoundsOptions): ViewportProps {\n  const {\n    width,\n    height,\n    bounds,\n    minExtent = 0, // 0.01 would be about 1000 meters (degree is ~110KM)\n    maxZoom = 24, // ~x4,000,000 => About 10 meter extents\n    offset = [0, 0]\n  } = options;\n\n  const [[west, south], [east, north]] = bounds;\n  const padding = getPaddingObject(options.padding);\n\n  const nw = lngLatToWorld([west, clamp(north, -MAX_LATITUDE, MAX_LATITUDE)]);\n  const se = lngLatToWorld([east, clamp(south, -MAX_LATITUDE, MAX_LATITUDE)]);\n\n  // width/height on the Web Mercator plane\n  const size = [\n    Math.max(Math.abs(se[0] - nw[0]), minExtent),\n    Math.max(Math.abs(se[1] - nw[1]), minExtent)\n  ];\n\n  const targetSize = [\n    width - padding.left - padding.right - Math.abs(offset[0]) * 2,\n    height - padding.top - padding.bottom - Math.abs(offset[1]) * 2\n  ];\n\n  assert(targetSize[0] > 0 && targetSize[1] > 0);\n\n  // scale = screen pixels per unit on the Web Mercator plane\n  const scaleX = targetSize[0] / size[0];\n  const scaleY = targetSize[1] / size[1];\n\n  // Find how much we need to shift the center\n  const offsetX = (padding.right - padding.left) / 2 / scaleX;\n  const offsetY = (padding.top - padding.bottom) / 2 / scaleY;\n\n  const center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];\n\n  const centerLngLat = worldToLngLat(center);\n  const zoom = Math.min(maxZoom, log2(Math.abs(Math.min(scaleX, scaleY))));\n\n  assert(Number.isFinite(zoom));\n\n  return {\n    longitude: centerLngLat[0],\n    latitude: centerLngLat[1],\n    zoom\n  };\n}\n\n// Helpers\nfunction getPaddingObject(padding: number | Padding = 0): Padding {\n  if (typeof padding === 'number') {\n    return {\n      top: padding,\n      bottom: padding,\n      left: padding,\n      right: padding\n    };\n  }\n\n  // Make sure all the required properties are set\n  assert(\n    Number.isFinite(padding.top) &&\n      Number.isFinite(padding.bottom) &&\n      Number.isFinite(padding.left) &&\n      Number.isFinite(padding.right)\n  );\n\n  return padding;\n}\n"]},"metadata":{},"sourceType":"module"}