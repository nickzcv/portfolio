{"ast":null,"code":"import _classCallCheck from \"/home/nick/Documents/GitHub/portfolio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/nick/Documents/GitHub/portfolio/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/nick/Documents/GitHub/portfolio/client/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/nick/Documents/GitHub/portfolio/client/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport Input from './input';\nimport { INPUT_EVENT_TYPES } from '../constants';\nvar MOUSE_EVENTS = INPUT_EVENT_TYPES.MOUSE_EVENTS;\nvar MOVE_EVENT_TYPE = 'pointermove';\nvar OVER_EVENT_TYPE = 'pointerover';\nvar OUT_EVENT_TYPE = 'pointerout';\nvar ENTER_EVENT_TYPE = 'pointerenter';\nvar LEAVE_EVENT_TYPE = 'pointerleave';\n/**\n * Hammer.js swallows 'move' events (for pointer/touch/mouse)\n * when the pointer is not down. This class sets up a handler\n * specifically for these events to work around this limitation.\n * Note that this could be extended to more intelligently handle\n * move events across input types, e.g. storing multiple simultaneous\n * pointer/touch events, calculating speed/direction, etc.\n */\n\nvar MoveInput = /*#__PURE__*/function (_Input) {\n  _inherits(MoveInput, _Input);\n\n  var _super = _createSuper(MoveInput);\n\n  function MoveInput(element, callback, options) {\n    var _this;\n\n    _classCallCheck(this, MoveInput);\n\n    _this = _super.call(this, element, callback, options);\n\n    _this.handleEvent = function (event) {\n      _this.handleOverEvent(event);\n\n      _this.handleOutEvent(event);\n\n      _this.handleEnterEvent(event);\n\n      _this.handleLeaveEvent(event);\n\n      _this.handleMoveEvent(event);\n    };\n\n    _this.pressed = false;\n    var enable = _this.options.enable;\n    _this.enableMoveEvent = enable;\n    _this.enableLeaveEvent = enable;\n    _this.enableEnterEvent = enable;\n    _this.enableOutEvent = enable;\n    _this.enableOverEvent = enable;\n    _this.events = (_this.options.events || []).concat(MOUSE_EVENTS);\n\n    _this.events.forEach(function (event) {\n      return element.addEventListener(event, _this.handleEvent);\n    });\n\n    return _this;\n  }\n\n  _createClass(MoveInput, [{\n    key: \"destroy\",\n    value: function destroy() {\n      var _this2 = this;\n\n      this.events.forEach(function (event) {\n        return _this2.element.removeEventListener(event, _this2.handleEvent);\n      });\n    }\n    /**\n     * Enable this input (begin processing events)\n     * if the specified event type is among those handled by this input.\n     */\n\n  }, {\n    key: \"enableEventType\",\n    value: function enableEventType(eventType, enabled) {\n      if (eventType === MOVE_EVENT_TYPE) {\n        this.enableMoveEvent = enabled;\n      }\n\n      if (eventType === OVER_EVENT_TYPE) {\n        this.enableOverEvent = enabled;\n      }\n\n      if (eventType === OUT_EVENT_TYPE) {\n        this.enableOutEvent = enabled;\n      }\n\n      if (eventType === ENTER_EVENT_TYPE) {\n        this.enableEnterEvent = enabled;\n      }\n\n      if (eventType === LEAVE_EVENT_TYPE) {\n        this.enableLeaveEvent = enabled;\n      }\n    }\n  }, {\n    key: \"handleOverEvent\",\n    value: function handleOverEvent(event) {\n      if (this.enableOverEvent) {\n        if (event.type === 'mouseover') {\n          this._emit(OVER_EVENT_TYPE, event);\n        }\n      }\n    }\n  }, {\n    key: \"handleOutEvent\",\n    value: function handleOutEvent(event) {\n      if (this.enableOutEvent) {\n        if (event.type === 'mouseout') {\n          this._emit(OUT_EVENT_TYPE, event);\n        }\n      }\n    }\n  }, {\n    key: \"handleEnterEvent\",\n    value: function handleEnterEvent(event) {\n      if (this.enableEnterEvent) {\n        if (event.type === 'mouseenter') {\n          this._emit(ENTER_EVENT_TYPE, event);\n        }\n      }\n    }\n  }, {\n    key: \"handleLeaveEvent\",\n    value: function handleLeaveEvent(event) {\n      if (this.enableLeaveEvent) {\n        if (event.type === 'mouseleave') {\n          this._emit(LEAVE_EVENT_TYPE, event);\n        }\n      }\n    }\n  }, {\n    key: \"handleMoveEvent\",\n    value: function handleMoveEvent(event) {\n      if (this.enableMoveEvent) {\n        switch (event.type) {\n          case 'mousedown':\n            if (event.button >= 0) {\n              // Button is down\n              this.pressed = true;\n            }\n\n            break;\n\n          case 'mousemove':\n            // Move events use `which` to track the button being pressed\n            if (event.which === 0) {\n              // Button is not down\n              this.pressed = false;\n            }\n\n            if (!this.pressed) {\n              // Drag events are emitted by hammer already\n              // we just need to emit the move event on hover\n              this._emit(MOVE_EVENT_TYPE, event);\n            }\n\n            break;\n\n          case 'mouseup':\n            this.pressed = false;\n            break;\n\n          default:\n        }\n      }\n    }\n  }, {\n    key: \"_emit\",\n    value: function _emit(type, event) {\n      this.callback({\n        type: type,\n        center: {\n          x: event.clientX,\n          y: event.clientY\n        },\n        srcEvent: event,\n        pointerType: 'mouse',\n        target: event.target\n      });\n    }\n  }]);\n\n  return MoveInput;\n}(Input);\n\nexport { MoveInput as default };","map":{"version":3,"sources":["../../../src/inputs/move-input.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import Input from './input';\nimport { INPUT_EVENT_TYPES } from '../constants';\nconst { MOUSE_EVENTS } = INPUT_EVENT_TYPES;\nconst MOVE_EVENT_TYPE = 'pointermove';\nconst OVER_EVENT_TYPE = 'pointerover';\nconst OUT_EVENT_TYPE = 'pointerout';\nconst ENTER_EVENT_TYPE = 'pointerenter';\nconst LEAVE_EVENT_TYPE = 'pointerleave';\n/**\n * Hammer.js swallows 'move' events (for pointer/touch/mouse)\n * when the pointer is not down. This class sets up a handler\n * specifically for these events to work around this limitation.\n * Note that this could be extended to more intelligently handle\n * move events across input types, e.g. storing multiple simultaneous\n * pointer/touch events, calculating speed/direction, etc.\n */\nexport default class MoveInput extends Input {\n    constructor(element, callback, options) {\n        super(element, callback, options);\n        this.handleEvent = (event) => {\n            this.handleOverEvent(event);\n            this.handleOutEvent(event);\n            this.handleEnterEvent(event);\n            this.handleLeaveEvent(event);\n            this.handleMoveEvent(event);\n        };\n        this.pressed = false;\n        const { enable } = this.options;\n        this.enableMoveEvent = enable;\n        this.enableLeaveEvent = enable;\n        this.enableEnterEvent = enable;\n        this.enableOutEvent = enable;\n        this.enableOverEvent = enable;\n        this.events = (this.options.events || []).concat(MOUSE_EVENTS);\n        this.events.forEach(event => element.addEventListener(event, this.handleEvent));\n    }\n    destroy() {\n        this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));\n    }\n    /**\n     * Enable this input (begin processing events)\n     * if the specified event type is among those handled by this input.\n     */\n    enableEventType(eventType, enabled) {\n        if (eventType === MOVE_EVENT_TYPE) {\n            this.enableMoveEvent = enabled;\n        }\n        if (eventType === OVER_EVENT_TYPE) {\n            this.enableOverEvent = enabled;\n        }\n        if (eventType === OUT_EVENT_TYPE) {\n            this.enableOutEvent = enabled;\n        }\n        if (eventType === ENTER_EVENT_TYPE) {\n            this.enableEnterEvent = enabled;\n        }\n        if (eventType === LEAVE_EVENT_TYPE) {\n            this.enableLeaveEvent = enabled;\n        }\n    }\n    handleOverEvent(event) {\n        if (this.enableOverEvent) {\n            if (event.type === 'mouseover') {\n                this._emit(OVER_EVENT_TYPE, event);\n            }\n        }\n    }\n    handleOutEvent(event) {\n        if (this.enableOutEvent) {\n            if (event.type === 'mouseout') {\n                this._emit(OUT_EVENT_TYPE, event);\n            }\n        }\n    }\n    handleEnterEvent(event) {\n        if (this.enableEnterEvent) {\n            if (event.type === 'mouseenter') {\n                this._emit(ENTER_EVENT_TYPE, event);\n            }\n        }\n    }\n    handleLeaveEvent(event) {\n        if (this.enableLeaveEvent) {\n            if (event.type === 'mouseleave') {\n                this._emit(LEAVE_EVENT_TYPE, event);\n            }\n        }\n    }\n    handleMoveEvent(event) {\n        if (this.enableMoveEvent) {\n            switch (event.type) {\n                case 'mousedown':\n                    if (event.button >= 0) {\n                        // Button is down\n                        this.pressed = true;\n                    }\n                    break;\n                case 'mousemove':\n                    // Move events use `which` to track the button being pressed\n                    if (event.which === 0) {\n                        // Button is not down\n                        this.pressed = false;\n                    }\n                    if (!this.pressed) {\n                        // Drag events are emitted by hammer already\n                        // we just need to emit the move event on hover\n                        this._emit(MOVE_EVENT_TYPE, event);\n                    }\n                    break;\n                case 'mouseup':\n                    this.pressed = false;\n                    break;\n                default:\n            }\n        }\n    }\n    _emit(type, event) {\n        this.callback({\n            type,\n            center: {\n                x: event.clientX,\n                y: event.clientY\n            },\n            srcEvent: event,\n            pointerType: 'mouse',\n            target: event.target\n        });\n    }\n}\n//# sourceMappingURL=move-input.js.map"]},"metadata":{},"sourceType":"module"}