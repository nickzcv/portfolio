{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { createMat4 } from './math-utils';\nimport { zoomToScale, pixelsToWorld, lngLatToWorld, worldToLngLat, worldToPixels, altitudeToFovy, fovyToAltitude, DEFAULT_ALTITUDE, getProjectionMatrix, getDistanceScales, getViewMatrix } from './web-mercator-utils';\nimport fitBounds from './fit-bounds';\nimport getBounds from './get-bounds';\nimport * as mat4 from 'gl-matrix/mat4';\nimport * as vec2 from 'gl-matrix/vec2';\nimport * as vec3 from 'gl-matrix/vec3';\nexport default class WebMercatorViewport {\n  constructor() {\n    var _this = this;\n\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      width: 1,\n      height: 1\n    };\n\n    _defineProperty(this, \"latitude\", void 0);\n\n    _defineProperty(this, \"longitude\", void 0);\n\n    _defineProperty(this, \"zoom\", void 0);\n\n    _defineProperty(this, \"pitch\", void 0);\n\n    _defineProperty(this, \"bearing\", void 0);\n\n    _defineProperty(this, \"altitude\", void 0);\n\n    _defineProperty(this, \"fovy\", void 0);\n\n    _defineProperty(this, \"meterOffset\", void 0);\n\n    _defineProperty(this, \"center\", void 0);\n\n    _defineProperty(this, \"width\", void 0);\n\n    _defineProperty(this, \"height\", void 0);\n\n    _defineProperty(this, \"scale\", void 0);\n\n    _defineProperty(this, \"distanceScales\", void 0);\n\n    _defineProperty(this, \"viewMatrix\", void 0);\n\n    _defineProperty(this, \"projectionMatrix\", void 0);\n\n    _defineProperty(this, \"viewProjectionMatrix\", void 0);\n\n    _defineProperty(this, \"pixelProjectionMatrix\", void 0);\n\n    _defineProperty(this, \"pixelUnprojectionMatrix\", void 0);\n\n    _defineProperty(this, \"equals\", viewport => {\n      if (!(viewport instanceof WebMercatorViewport)) {\n        return false;\n      }\n\n      return viewport.width === this.width && viewport.height === this.height && mat4.equals(viewport.projectionMatrix, this.projectionMatrix) && mat4.equals(viewport.viewMatrix, this.viewMatrix);\n    });\n\n    _defineProperty(this, \"project\", function (lngLatZ) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const {\n        topLeft = true\n      } = options;\n\n      const worldPosition = _this.projectPosition(lngLatZ);\n\n      const coord = worldToPixels(worldPosition, _this.pixelProjectionMatrix);\n      const [x, y] = coord;\n      const y2 = topLeft ? y : _this.height - y;\n      return lngLatZ.length === 2 ? [x, y2] : [x, y2, coord[2]];\n    });\n\n    _defineProperty(this, \"unproject\", function (xyz) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const {\n        topLeft = true,\n        targetZ = undefined\n      } = options;\n      const [x, y, z] = xyz;\n      const y2 = topLeft ? y : _this.height - y;\n      const targetZWorld = targetZ && targetZ * _this.distanceScales.unitsPerMeter[2];\n      const coord = pixelsToWorld([x, y2, z], _this.pixelUnprojectionMatrix, targetZWorld);\n\n      const [X, Y, Z] = _this.unprojectPosition(coord);\n\n      if (Number.isFinite(z)) {\n        return [X, Y, Z];\n      }\n\n      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n    });\n\n    _defineProperty(this, \"projectPosition\", xyz => {\n      const [X, Y] = lngLatToWorld(xyz);\n      const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n      return [X, Y, Z];\n    });\n\n    _defineProperty(this, \"unprojectPosition\", xyz => {\n      const [X, Y] = worldToLngLat(xyz);\n      const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n      return [X, Y, Z];\n    });\n\n    let {\n      width,\n      height,\n      altitude = null,\n      fovy = null\n    } = props;\n    const {\n      latitude = 0,\n      longitude = 0,\n      zoom = 0,\n      pitch = 0,\n      bearing = 0,\n      position = null,\n      nearZMultiplier = 0.02,\n      farZMultiplier = 1.01\n    } = props;\n    width = width || 1;\n    height = height || 1;\n\n    if (fovy === null && altitude === null) {\n      altitude = DEFAULT_ALTITUDE;\n      fovy = altitudeToFovy(altitude);\n    } else if (fovy === null) {\n      fovy = altitudeToFovy(altitude);\n    } else if (altitude === null) {\n      altitude = fovyToAltitude(fovy);\n    }\n\n    const scale = zoomToScale(zoom);\n    altitude = Math.max(0.75, altitude);\n    const distanceScales = getDistanceScales({\n      longitude,\n      latitude\n    });\n    const center = lngLatToWorld([longitude, latitude]);\n    center.push(0);\n\n    if (position) {\n      vec3.add(center, center, vec3.mul([], position, distanceScales.unitsPerMeter));\n    }\n\n    this.projectionMatrix = getProjectionMatrix({\n      width,\n      height,\n      scale,\n      center,\n      pitch,\n      fovy,\n      nearZMultiplier,\n      farZMultiplier\n    });\n    this.viewMatrix = getViewMatrix({\n      height,\n      scale,\n      center,\n      pitch,\n      bearing,\n      altitude\n    });\n    this.width = width;\n    this.height = height;\n    this.scale = scale;\n    this.latitude = latitude;\n    this.longitude = longitude;\n    this.zoom = zoom;\n    this.pitch = pitch;\n    this.bearing = bearing;\n    this.altitude = altitude;\n    this.fovy = fovy;\n    this.center = center;\n    this.meterOffset = position || [0, 0, 0];\n    this.distanceScales = distanceScales;\n\n    this._initMatrices();\n\n    Object.freeze(this);\n  }\n\n  _initMatrices() {\n    const {\n      width,\n      height,\n      projectionMatrix,\n      viewMatrix\n    } = this;\n    const vpm = createMat4();\n    mat4.multiply(vpm, vpm, projectionMatrix);\n    mat4.multiply(vpm, vpm, viewMatrix);\n    this.viewProjectionMatrix = vpm;\n    const m = createMat4();\n    mat4.scale(m, m, [width / 2, -height / 2, 1]);\n    mat4.translate(m, m, [1, -1, 0]);\n    mat4.multiply(m, m, vpm);\n    const mInverse = mat4.invert(createMat4(), m);\n\n    if (!mInverse) {\n      throw new Error('Pixel project matrix not invertible');\n    }\n\n    this.pixelProjectionMatrix = m;\n    this.pixelUnprojectionMatrix = mInverse;\n  }\n\n  projectFlat(lngLat) {\n    return lngLatToWorld(lngLat);\n  }\n\n  unprojectFlat(xy) {\n    return worldToLngLat(xy);\n  }\n\n  getMapCenterByLngLatPosition(_ref) {\n    let {\n      lngLat,\n      pos\n    } = _ref;\n    const fromLocation = pixelsToWorld(pos, this.pixelUnprojectionMatrix);\n    const toLocation = lngLatToWorld(lngLat);\n    const translate = vec2.add([], toLocation, vec2.negate([], fromLocation));\n    const newCenter = vec2.add([], this.center, translate);\n    return worldToLngLat(newCenter);\n  }\n\n  fitBounds(bounds) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      width,\n      height\n    } = this;\n    const {\n      longitude,\n      latitude,\n      zoom\n    } = fitBounds(Object.assign({\n      width,\n      height,\n      bounds\n    }, options));\n    return new WebMercatorViewport({\n      width,\n      height,\n      longitude,\n      latitude,\n      zoom\n    });\n  }\n\n  getBounds(options) {\n    const corners = this.getBoundingRegion(options);\n    const west = Math.min(...corners.map(p => p[0]));\n    const east = Math.max(...corners.map(p => p[0]));\n    const south = Math.min(...corners.map(p => p[1]));\n    const north = Math.max(...corners.map(p => p[1]));\n    return [[west, south], [east, north]];\n  }\n\n  getBoundingRegion() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return getBounds(this, options.z || 0);\n  }\n\n  getLocationAtPoint(_ref2) {\n    let {\n      lngLat,\n      pos\n    } = _ref2;\n    return this.getMapCenterByLngLatPosition({\n      lngLat,\n      pos\n    });\n  }\n\n}","map":{"version":3,"sources":["../../src/web-mercator-viewport.ts"],"names":["constructor","props","width","height","altitude","fovy","latitude","longitude","zoom","pitch","bearing","position","nearZMultiplier","farZMultiplier","altitudeToFovy","fovyToAltitude","scale","zoomToScale","Math","distanceScales","getDistanceScales","center","lngLatToWorld","vec3","getProjectionMatrix","getViewMatrix","Object","_initMatrices","viewMatrix","vpm","createMat4","mat4","m","mInverse","viewport","options","topLeft","worldPosition","coord","worldToPixels","y2","lngLatZ","targetZ","undefined","targetZWorld","pixelsToWorld","Number","xyz","Z","worldToLngLat","projectFlat","unprojectFlat","getMapCenterByLngLatPosition","pos","fromLocation","toLocation","translate","vec2","newCenter","fitBounds","bounds","getBounds","corners","west","p","east","south","north","getBoundingRegion","getLocationAtPoint"],"mappings":"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","sourcesContent":["// View and Projection Matrix calculations for mapbox-js style map view properties\nimport {createMat4} from './math-utils';\n\nimport {\n  zoomToScale,\n  pixelsToWorld,\n  lngLatToWorld,\n  worldToLngLat,\n  worldToPixels,\n  altitudeToFovy,\n  fovyToAltitude,\n  DEFAULT_ALTITUDE,\n  getProjectionMatrix,\n  getDistanceScales,\n  getViewMatrix,\n  DistanceScales\n} from './web-mercator-utils';\nimport fitBounds from './fit-bounds';\nimport getBounds from './get-bounds';\nimport type {FitBoundsOptions} from './fit-bounds';\n\nimport * as mat4 from 'gl-matrix/mat4';\nimport * as vec2 from 'gl-matrix/vec2';\nimport * as vec3 from 'gl-matrix/vec3';\n\n/**\n   * @param width=1 - Width of \"viewport\" or window\n   * @param height=1 - Height of \"viewport\" or window\n   * @param scale=1 - Either use scale or zoom\n   * @param pitch=0 - Camera angle in degrees (0 is straight down)\n   * @param bearing=0 - Map rotation in degrees (0 means north is up)\n   * @param fovy= - Field of view of camera in degrees\n   * @param altitude= - Altitude of camera in screen units                                                               \n   *\n   * Web mercator projection short-hand parameters\n   * @param latitude - Center of viewport on map\n   * @param longitude - Center of viewport on map\n   * @param zoom - Scale = Math.pow(2,zoom) on map\n\n   * Notes:\n   *  - Only one of center or [latitude, longitude] can be specified\n   *  - [latitude, longitude] can only be specified when \"mercator\" is true\n   *  - Altitude has a default value that matches assumptions in mapbox-gl\n   *  - Field of view is independent from altitude, provide `altitudeToFovy(1.5)` (default value) to match assumptions in mapbox-gl\n   *  - width and height are forced to 1 if supplied as 0, to avoid\n   *    division by zero. This is intended to reduce the burden of apps to\n   *    to check values before instantiating a Viewport.\n */\nexport type WebMercatorViewportProps = {\n  // Map state\n  width: number;\n  height: number;\n  latitude?: number;\n  longitude?: number;\n  position?: number[];\n  zoom?: number;\n  pitch?: number;\n  bearing?: number;\n  altitude?: number;\n  fovy?: number;\n  nearZMultiplier?: number;\n  farZMultiplier?: number;\n};\n\n/**\n * The WebMercatorViewport class creates\n * - view/projection matrices\n * - \"uniform values\" (for shaders) from mercator params\n *\n * Note: Instances are immutable in the sense that they only have accessors.\n * A new viewport instance should be created if any parameters have changed.\n */\nexport default class WebMercatorViewport {\n  readonly latitude: number;\n  readonly longitude: number;\n  readonly zoom: number;\n  readonly pitch: number;\n  readonly bearing: number;\n  readonly altitude: number;\n  readonly fovy: number;\n\n  readonly meterOffset: number[];\n  readonly center: number[];\n\n  readonly width: number;\n  readonly height: number;\n  readonly scale: number;\n  readonly distanceScales: DistanceScales;\n\n  readonly viewMatrix: number[];\n  readonly projectionMatrix: number[];\n\n  viewProjectionMatrix: number[];\n  pixelProjectionMatrix: number[];\n  pixelUnprojectionMatrix: number[];\n\n  /**\n   * @classdesc\n   * Creates view/projection matrices from mercator params\n   * Note: The Viewport is immutable in the sense that it only has accessors.\n   * A new viewport instance should be created if any parameters have changed.\n   */\n  // eslint-disable-next-line max-statements\n  constructor(props: WebMercatorViewportProps = {width: 1, height: 1}) {\n    let {\n      // Map state\n      width,\n      height,\n      altitude = null,\n      fovy = null\n    } = props;\n    const {\n      latitude = 0,\n      longitude = 0,\n      zoom = 0,\n      pitch = 0,\n      bearing = 0,\n      position = null,\n      nearZMultiplier = 0.02,\n      farZMultiplier = 1.01\n    } = props;\n\n    // Silently allow apps to send in 0,0 to facilitate isomorphic render etc\n    width = width || 1;\n    height = height || 1;\n\n    // `fovy` & `altitude` are independent parameters, one for the\n    // projection and the latter for the view matrix. In the past,\n    // the `fovy` was always derived from the `altitude`\n    if (fovy === null && altitude === null) {\n      altitude = DEFAULT_ALTITUDE;\n      fovy = altitudeToFovy(altitude);\n    } else if (fovy === null) {\n      fovy = altitudeToFovy(altitude);\n    } else if (altitude === null) {\n      altitude = fovyToAltitude(fovy);\n    }\n\n    const scale = zoomToScale(zoom);\n    // Altitude - prevent division by 0\n    // TODO - just throw an Error instead?\n    altitude = Math.max(0.75, altitude);\n\n    const distanceScales = getDistanceScales({longitude, latitude});\n\n    const center: number[] = lngLatToWorld([longitude, latitude]);\n    center.push(0);\n\n    if (position) {\n      vec3.add(center, center, vec3.mul([], position, distanceScales.unitsPerMeter));\n    }\n\n    this.projectionMatrix = getProjectionMatrix({\n      width,\n      height,\n      scale,\n      center,\n      pitch,\n      fovy,\n      nearZMultiplier,\n      farZMultiplier\n    });\n\n    this.viewMatrix = getViewMatrix({\n      height,\n      scale,\n      center,\n      pitch,\n      bearing,\n      altitude\n    });\n\n    // Save parameters\n    this.width = width;\n    this.height = height;\n    this.scale = scale;\n\n    this.latitude = latitude;\n    this.longitude = longitude;\n    this.zoom = zoom;\n    this.pitch = pitch;\n    this.bearing = bearing;\n    this.altitude = altitude;\n    this.fovy = fovy;\n    this.center = center;\n    this.meterOffset = position || [0, 0, 0];\n\n    this.distanceScales = distanceScales;\n\n    this._initMatrices();\n\n    Object.freeze(this);\n  }\n\n  _initMatrices(): void {\n    const {width, height, projectionMatrix, viewMatrix} = this;\n\n    // Note: As usual, matrix operations should be applied in \"reverse\" order\n    // since vectors will be multiplied in from the right during transformation\n    const vpm = createMat4();\n    mat4.multiply(vpm, vpm, projectionMatrix);\n    mat4.multiply(vpm, vpm, viewMatrix);\n    this.viewProjectionMatrix = vpm;\n\n    // Calculate matrices and scales needed for projection\n    /**\n     * Builds matrices that converts preprojected lngLats to screen pixels\n     * and vice versa.\n     * Note: Currently returns bottom-left coordinates!\n     * Note: Starts with the GL projection matrix and adds steps to the\n     *       scale and translate that matrix onto the window.\n     * Note: WebGL controls clip space to screen projection with gl.viewport\n     *       and does not need this step.\n     */\n    const m = createMat4();\n\n    // matrix for conversion from location to screen coordinates\n    mat4.scale(m, m, [width / 2, -height / 2, 1]);\n    mat4.translate(m, m, [1, -1, 0]);\n    mat4.multiply(m, m, vpm);\n\n    const mInverse = mat4.invert(createMat4(), m);\n    if (!mInverse) {\n      throw new Error('Pixel project matrix not invertible');\n    }\n\n    this.pixelProjectionMatrix = m;\n    this.pixelUnprojectionMatrix = mInverse;\n  }\n\n  /** Two viewports are equal if width and height are identical, and if\n   * their view and projection matrices are (approximately) equal.\n   */\n  equals = (viewport: WebMercatorViewport | null): boolean => {\n    if (!(viewport instanceof WebMercatorViewport)) {\n      return false;\n    }\n\n    return (\n      viewport.width === this.width &&\n      viewport.height === this.height &&\n      mat4.equals(viewport.projectionMatrix, this.projectionMatrix) &&\n      mat4.equals(viewport.viewMatrix, this.viewMatrix)\n    );\n  };\n\n  /**\n   * Projects xyz (possibly latitude and longitude) to pixel coordinates in window\n   * using viewport projection parameters\n   * - [longitude, latitude] to [x, y]\n   * - [longitude, latitude, Z] => [x, y, z]\n   * Note: By default, returns top-left coordinates for canvas/SVG type render\n   *\n   * @param lngLatZ - [lng, lat] or [lng, lat, Z]\n   * @param options - options\n   * @param options.topLeft=true - Whether projected coords are top left\n   * @return - screen coordinates [x, y] or [x, y, z], z as pixel depth\n   */\n  project = (lngLatZ: number[], options: {topLeft?: boolean} = {}): number[] => {\n    const {topLeft = true} = options;\n    const worldPosition = this.projectPosition(lngLatZ);\n    const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n\n    const [x, y] = coord;\n    const y2 = topLeft ? y : this.height - y;\n    return lngLatZ.length === 2 ? [x, y2] : [x, y2, coord[2]];\n  };\n\n  /**\n   * Unproject pixel coordinates on screen onto world coordinates, possibly `[lon, lat]` on map.\n   *\n   * - [x, y] => [lng, lat]\n   * - [x, y, z] => [lng, lat, Z]\n   *\n   * @param xyz - screen coordinates, z as pixel depth\n   * @param options - options\n   * @param options.topLeft=true - Whether projected coords are top left\n   * @param options.targetZ=0 - If pixel depth is unknown, targetZ is used as\n   *   the elevation plane to unproject onto\n   * @return - [lng, lat, Z] or [X, Y, Z]\n   */\n  unproject = (xyz: number[], options: {topLeft?: boolean; targetZ?: number} = {}): number[] => {\n    const {topLeft = true, targetZ = undefined} = options;\n    const [x, y, z] = xyz;\n\n    const y2 = topLeft ? y : this.height - y;\n    const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];\n    const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n    const [X, Y, Z] = this.unprojectPosition(coord);\n\n    if (Number.isFinite(z)) {\n      return [X, Y, Z];\n    }\n    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n  };\n\n  // NON_LINEAR PROJECTION HOOKS\n  // Used for web meractor projection\n\n  projectPosition = (xyz: number[]): [number, number, number] => {\n    const [X, Y] = lngLatToWorld(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n    return [X, Y, Z];\n  };\n\n  unprojectPosition = (xyz: number[]): [number, number, number] => {\n    const [X, Y] = worldToLngLat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n    return [X, Y, Z];\n  };\n\n  /**\n   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n   * Performs the nonlinear part of the web mercator projection.\n   * Remaining projection is done with 4x4 matrices which also handles\n   * perspective.\n   *\n   * @param lngLat - [lng, lat] coordinates\n   *   Specifies a point on the sphere to project onto the map.\n   * @return [x,y] coordinates.\n   */\n  projectFlat(lngLat: number[]): number[] {\n    return lngLatToWorld(lngLat);\n  }\n\n  /**\n   * Unproject world point [x,y] on map onto {lat, lon} on sphere\n   *\n   * @param xy - array with [x,y] members\n   *  representing point on projected map plane\n   * @return - array with [lat,lon] of point on sphere.\n   *   Has toArray method if you need a GeoJSON Array.\n   *   Per cartographic tradition, lat and lon are specified as degrees.\n   */\n  unprojectFlat(xy: number[]): number[] {\n    return worldToLngLat(xy);\n  }\n\n  /**\n   * Get the map center that place a given [lng, lat] coordinate at screen point [x, y]\n   * @param opt\n   * @param opt.lngLat - [lng,lat] coordinates\n   *   Specifies a point on the sphere.\n   * @param opt.pos - [x,y] coordinates\n   *   Specifies a point on the screen.\n   * @return [lng,lat] new map center.\n   */\n  getMapCenterByLngLatPosition({lngLat, pos}: {lngLat: number[]; pos: number[]}): number[] {\n    const fromLocation = pixelsToWorld(pos, this.pixelUnprojectionMatrix);\n    const toLocation = lngLatToWorld(lngLat);\n    const translate = vec2.add([], toLocation, vec2.negate([], fromLocation));\n    const newCenter = vec2.add([], this.center, translate);\n    return worldToLngLat(newCenter);\n  }\n\n  /**\n   * Returns a new viewport that fit around the given rectangle.\n   * Only supports non-perspective mode.\n   * @param bounds - [[lon, lat], [lon, lat]]\n   * @param [options]\n   * @param [options.padding] - The amount of padding in pixels to add to the given bounds.\n   * @param [options.offset] - The center of the given bounds relative to the map's center,\n   *    [x, y] measured in pixels.\n   * @returns {WebMercatorViewport}\n   */\n  fitBounds(\n    bounds: [[number, number], [number, number]],\n    options: Omit<FitBoundsOptions, 'width' | 'height' | 'bounds'> = {}\n  ): WebMercatorViewport {\n    const {width, height} = this;\n    const {longitude, latitude, zoom} = fitBounds(Object.assign({width, height, bounds}, options));\n    return new WebMercatorViewport({width, height, longitude, latitude, zoom});\n  }\n\n  /**\n   * Returns the bounding box of the viewport.\n   * @param [options]\n   * @param [options.z] - The altitude at which the bounds should be calculated.\n   * @returns {Array} bounds - [[lon, lat], [lon, lat]]\n   */\n  getBounds(options?: {z?: number}): number[][] {\n    const corners = this.getBoundingRegion(options);\n\n    const west = Math.min(...corners.map((p) => p[0]));\n    const east = Math.max(...corners.map((p) => p[0]));\n    const south = Math.min(...corners.map((p) => p[1]));\n    const north = Math.max(...corners.map((p) => p[1]));\n    return [\n      [west, south],\n      [east, north]\n    ];\n  }\n\n  /**\n   * Returns the bounding box of the viewport.\n   * @param [options]\n   * @param [options.z] - The altitude at which the bounds should be calculated.\n   * @returns {Array} an array of 4 points that define the visible region\n   */\n  getBoundingRegion(options: {z?: number} = {}): number[][] {\n    return getBounds(this, options.z || 0);\n  }\n\n  // DEPRECATED\n\n  /** @deprecated Legacy method name */\n  getLocationAtPoint({lngLat, pos}: {lngLat: number[]; pos: number[]}): number[] {\n    return this.getMapCenterByLngLatPosition({lngLat, pos});\n  }\n}\n"]},"metadata":{},"sourceType":"module"}