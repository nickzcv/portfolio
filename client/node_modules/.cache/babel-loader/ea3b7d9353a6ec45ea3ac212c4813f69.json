{"ast":null,"code":"export var ANCHOR_POSITION = {\n  top: {\n    x: 0.5,\n    y: 0\n  },\n  'top-left': {\n    x: 0,\n    y: 0\n  },\n  'top-right': {\n    x: 1,\n    y: 0\n  },\n  bottom: {\n    x: 0.5,\n    y: 1\n  },\n  'bottom-left': {\n    x: 0,\n    y: 1\n  },\n  'bottom-right': {\n    x: 1,\n    y: 1\n  },\n  left: {\n    x: 0,\n    y: 0.5\n  },\n  right: {\n    x: 1,\n    y: 0.5\n  }\n};\nvar ANCHOR_TYPES = Object.keys(ANCHOR_POSITION);\nexport function getDynamicPosition(_ref) {\n  var x = _ref.x,\n      y = _ref.y,\n      width = _ref.width,\n      height = _ref.height,\n      selfWidth = _ref.selfWidth,\n      selfHeight = _ref.selfHeight,\n      anchor = _ref.anchor,\n      _ref$padding = _ref.padding,\n      padding = _ref$padding === void 0 ? 0 : _ref$padding;\n  var _ANCHOR_POSITION$anch = ANCHOR_POSITION[anchor],\n      anchorX = _ANCHOR_POSITION$anch.x,\n      anchorY = _ANCHOR_POSITION$anch.y;\n  var top = y - anchorY * selfHeight;\n  var bottom = top + selfHeight;\n  var cutoffY = Math.max(0, padding - top) + Math.max(0, bottom - height + padding);\n\n  if (cutoffY > 0) {\n    var bestAnchorY = anchorY;\n    var minCutoff = cutoffY;\n\n    for (anchorY = 0; anchorY <= 1; anchorY += 0.5) {\n      top = y - anchorY * selfHeight;\n      bottom = top + selfHeight;\n      cutoffY = Math.max(0, padding - top) + Math.max(0, bottom - height + padding);\n\n      if (cutoffY < minCutoff) {\n        minCutoff = cutoffY;\n        bestAnchorY = anchorY;\n      }\n    }\n\n    anchorY = bestAnchorY;\n  }\n\n  var xStep = 0.5;\n\n  if (anchorY === 0.5) {\n    anchorX = Math.floor(anchorX);\n    xStep = 1;\n  }\n\n  var left = x - anchorX * selfWidth;\n  var right = left + selfWidth;\n  var cutoffX = Math.max(0, padding - left) + Math.max(0, right - width + padding);\n\n  if (cutoffX > 0) {\n    var bestAnchorX = anchorX;\n    var _minCutoff = cutoffX;\n\n    for (anchorX = 0; anchorX <= 1; anchorX += xStep) {\n      left = x - anchorX * selfWidth;\n      right = left + selfWidth;\n      cutoffX = Math.max(0, padding - left) + Math.max(0, right - width + padding);\n\n      if (cutoffX < _minCutoff) {\n        _minCutoff = cutoffX;\n        bestAnchorX = anchorX;\n      }\n    }\n\n    anchorX = bestAnchorX;\n  }\n\n  return ANCHOR_TYPES.find(function (positionType) {\n    var anchorPosition = ANCHOR_POSITION[positionType];\n    return anchorPosition.x === anchorX && anchorPosition.y === anchorY;\n  }) || anchor;\n}","map":{"version":3,"sources":["../../../src/utils/dynamic-position.js"],"names":["ANCHOR_POSITION","top","x","y","bottom","left","right","ANCHOR_TYPES","Object","width","height","selfWidth","selfHeight","anchor","padding","anchorX","anchorY","cutoffY","Math","bestAnchorY","minCutoff","xStep","cutoffX","bestAnchorX","anchorPosition"],"mappings":"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","sourcesContent":["export const ANCHOR_POSITION = {\n  top: {x: 0.5, y: 0},\n  'top-left': {x: 0, y: 0},\n  'top-right': {x: 1, y: 0},\n  bottom: {x: 0.5, y: 1},\n  'bottom-left': {x: 0, y: 1},\n  'bottom-right': {x: 1, y: 1},\n  left: {x: 0, y: 0.5},\n  right: {x: 1, y: 0.5}\n};\n\nconst ANCHOR_TYPES = Object.keys(ANCHOR_POSITION);\n\n/**\n * Calculate the dynamic position for a popup to fit in a container.\n * @param {Object} opts\n * @param {Number} opts.x - x position of the anchor on screen\n * @param {Number} opts.y - y position of the anchor on screen\n * @param {Number} opts.width - width of the container\n * @param {Number} opts.height - height of the container\n * @param {Number} opts.padding - extra space from the edge in pixels\n * @param {Number} opts.selfWidth - width of the popup\n * @param {Number} opts.selfHeight - height of the popup\n * @param {String} opts.anchor - type of the anchor, one of 'top', 'bottom',\n    'left', 'right', 'top-left', 'top-right', 'bottom-left' , and  'bottom-right'\n * @returns {String} position - one of 'top', 'bottom',\n    'left', 'right', 'top-left', 'top-right', 'bottom-left' , and  'bottom-right'\n */\n// eslint-disable-next-line complexity,max-statements\nexport function getDynamicPosition({\n  x,\n  y,\n  width,\n  height,\n  selfWidth,\n  selfHeight,\n  anchor,\n  padding = 0\n}) {\n  let {x: anchorX, y: anchorY} = ANCHOR_POSITION[anchor];\n\n  // anchorY: top - 0, center - 0.5, bottom - 1\n  let top = y - anchorY * selfHeight;\n  let bottom = top + selfHeight;\n  let cutoffY = Math.max(0, padding - top) + Math.max(0, bottom - height + padding);\n\n  if (cutoffY > 0) {\n    // Needs vertical adjustment\n    let bestAnchorY = anchorY;\n    let minCutoff = cutoffY;\n    // Test anchorY at 0.5 step between [0, 1]\n    for (anchorY = 0; anchorY <= 1; anchorY += 0.5) {\n      top = y - anchorY * selfHeight;\n      bottom = top + selfHeight;\n      cutoffY = Math.max(0, padding - top) + Math.max(0, bottom - height + padding);\n      if (cutoffY < minCutoff) {\n        minCutoff = cutoffY;\n        bestAnchorY = anchorY;\n      }\n    }\n    anchorY = bestAnchorY;\n  }\n\n  // If needed, adjust anchorX at 0.5 step between [0, 1]\n  let xStep = 0.5;\n  if (anchorY === 0.5) {\n    // If y is centered, then x cannot also be centered\n    anchorX = Math.floor(anchorX);\n    xStep = 1;\n  }\n\n  // anchorX: left - 0, center - 0.5, right - 1\n  let left = x - anchorX * selfWidth;\n  let right = left + selfWidth;\n  let cutoffX = Math.max(0, padding - left) + Math.max(0, right - width + padding);\n\n  if (cutoffX > 0) {\n    // Needs horizontal adjustment\n    let bestAnchorX = anchorX;\n    let minCutoff = cutoffX;\n    // Test anchorX at xStep between [0, 1]\n    for (anchorX = 0; anchorX <= 1; anchorX += xStep) {\n      left = x - anchorX * selfWidth;\n      right = left + selfWidth;\n      cutoffX = Math.max(0, padding - left) + Math.max(0, right - width + padding);\n      if (cutoffX < minCutoff) {\n        minCutoff = cutoffX;\n        bestAnchorX = anchorX;\n      }\n    }\n    anchorX = bestAnchorX;\n  }\n\n  // Find the name of the new anchor position\n  return (\n    ANCHOR_TYPES.find(positionType => {\n      const anchorPosition = ANCHOR_POSITION[positionType];\n      return anchorPosition.x === anchorX && anchorPosition.y === anchorY;\n    }) || anchor\n  );\n}\n"]},"metadata":{},"sourceType":"module"}