{"ast":null,"code":"import Input from './input';\nimport { INPUT_EVENT_TYPES } from '../constants';\nconst {\n  MOUSE_EVENTS\n} = INPUT_EVENT_TYPES;\nconst MOVE_EVENT_TYPE = 'pointermove';\nconst OVER_EVENT_TYPE = 'pointerover';\nconst OUT_EVENT_TYPE = 'pointerout';\nconst ENTER_EVENT_TYPE = 'pointerenter';\nconst LEAVE_EVENT_TYPE = 'pointerleave';\n/**\n * Hammer.js swallows 'move' events (for pointer/touch/mouse)\n * when the pointer is not down. This class sets up a handler\n * specifically for these events to work around this limitation.\n * Note that this could be extended to more intelligently handle\n * move events across input types, e.g. storing multiple simultaneous\n * pointer/touch events, calculating speed/direction, etc.\n */\n\nexport default class MoveInput extends Input {\n  constructor(element, callback, options) {\n    super(element, callback, options);\n\n    this.handleEvent = event => {\n      this.handleOverEvent(event);\n      this.handleOutEvent(event);\n      this.handleEnterEvent(event);\n      this.handleLeaveEvent(event);\n      this.handleMoveEvent(event);\n    };\n\n    this.pressed = false;\n    const {\n      enable\n    } = this.options;\n    this.enableMoveEvent = enable;\n    this.enableLeaveEvent = enable;\n    this.enableEnterEvent = enable;\n    this.enableOutEvent = enable;\n    this.enableOverEvent = enable;\n    this.events = (this.options.events || []).concat(MOUSE_EVENTS);\n    this.events.forEach(event => element.addEventListener(event, this.handleEvent));\n  }\n\n  destroy() {\n    this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));\n  }\n  /**\n   * Enable this input (begin processing events)\n   * if the specified event type is among those handled by this input.\n   */\n\n\n  enableEventType(eventType, enabled) {\n    if (eventType === MOVE_EVENT_TYPE) {\n      this.enableMoveEvent = enabled;\n    }\n\n    if (eventType === OVER_EVENT_TYPE) {\n      this.enableOverEvent = enabled;\n    }\n\n    if (eventType === OUT_EVENT_TYPE) {\n      this.enableOutEvent = enabled;\n    }\n\n    if (eventType === ENTER_EVENT_TYPE) {\n      this.enableEnterEvent = enabled;\n    }\n\n    if (eventType === LEAVE_EVENT_TYPE) {\n      this.enableLeaveEvent = enabled;\n    }\n  }\n\n  handleOverEvent(event) {\n    if (this.enableOverEvent) {\n      if (event.type === 'mouseover') {\n        this._emit(OVER_EVENT_TYPE, event);\n      }\n    }\n  }\n\n  handleOutEvent(event) {\n    if (this.enableOutEvent) {\n      if (event.type === 'mouseout') {\n        this._emit(OUT_EVENT_TYPE, event);\n      }\n    }\n  }\n\n  handleEnterEvent(event) {\n    if (this.enableEnterEvent) {\n      if (event.type === 'mouseenter') {\n        this._emit(ENTER_EVENT_TYPE, event);\n      }\n    }\n  }\n\n  handleLeaveEvent(event) {\n    if (this.enableLeaveEvent) {\n      if (event.type === 'mouseleave') {\n        this._emit(LEAVE_EVENT_TYPE, event);\n      }\n    }\n  }\n\n  handleMoveEvent(event) {\n    if (this.enableMoveEvent) {\n      switch (event.type) {\n        case 'mousedown':\n          if (event.button >= 0) {\n            // Button is down\n            this.pressed = true;\n          }\n\n          break;\n\n        case 'mousemove':\n          // Move events use `which` to track the button being pressed\n          if (event.which === 0) {\n            // Button is not down\n            this.pressed = false;\n          }\n\n          if (!this.pressed) {\n            // Drag events are emitted by hammer already\n            // we just need to emit the move event on hover\n            this._emit(MOVE_EVENT_TYPE, event);\n          }\n\n          break;\n\n        case 'mouseup':\n          this.pressed = false;\n          break;\n\n        default:\n      }\n    }\n  }\n\n  _emit(type, event) {\n    this.callback({\n      type,\n      center: {\n        x: event.clientX,\n        y: event.clientY\n      },\n      srcEvent: event,\n      pointerType: 'mouse',\n      target: event.target\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/inputs/move-input.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import Input from './input';\nimport { INPUT_EVENT_TYPES } from '../constants';\nconst { MOUSE_EVENTS } = INPUT_EVENT_TYPES;\nconst MOVE_EVENT_TYPE = 'pointermove';\nconst OVER_EVENT_TYPE = 'pointerover';\nconst OUT_EVENT_TYPE = 'pointerout';\nconst ENTER_EVENT_TYPE = 'pointerenter';\nconst LEAVE_EVENT_TYPE = 'pointerleave';\n/**\n * Hammer.js swallows 'move' events (for pointer/touch/mouse)\n * when the pointer is not down. This class sets up a handler\n * specifically for these events to work around this limitation.\n * Note that this could be extended to more intelligently handle\n * move events across input types, e.g. storing multiple simultaneous\n * pointer/touch events, calculating speed/direction, etc.\n */\nexport default class MoveInput extends Input {\n    constructor(element, callback, options) {\n        super(element, callback, options);\n        this.handleEvent = (event) => {\n            this.handleOverEvent(event);\n            this.handleOutEvent(event);\n            this.handleEnterEvent(event);\n            this.handleLeaveEvent(event);\n            this.handleMoveEvent(event);\n        };\n        this.pressed = false;\n        const { enable } = this.options;\n        this.enableMoveEvent = enable;\n        this.enableLeaveEvent = enable;\n        this.enableEnterEvent = enable;\n        this.enableOutEvent = enable;\n        this.enableOverEvent = enable;\n        this.events = (this.options.events || []).concat(MOUSE_EVENTS);\n        this.events.forEach(event => element.addEventListener(event, this.handleEvent));\n    }\n    destroy() {\n        this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));\n    }\n    /**\n     * Enable this input (begin processing events)\n     * if the specified event type is among those handled by this input.\n     */\n    enableEventType(eventType, enabled) {\n        if (eventType === MOVE_EVENT_TYPE) {\n            this.enableMoveEvent = enabled;\n        }\n        if (eventType === OVER_EVENT_TYPE) {\n            this.enableOverEvent = enabled;\n        }\n        if (eventType === OUT_EVENT_TYPE) {\n            this.enableOutEvent = enabled;\n        }\n        if (eventType === ENTER_EVENT_TYPE) {\n            this.enableEnterEvent = enabled;\n        }\n        if (eventType === LEAVE_EVENT_TYPE) {\n            this.enableLeaveEvent = enabled;\n        }\n    }\n    handleOverEvent(event) {\n        if (this.enableOverEvent) {\n            if (event.type === 'mouseover') {\n                this._emit(OVER_EVENT_TYPE, event);\n            }\n        }\n    }\n    handleOutEvent(event) {\n        if (this.enableOutEvent) {\n            if (event.type === 'mouseout') {\n                this._emit(OUT_EVENT_TYPE, event);\n            }\n        }\n    }\n    handleEnterEvent(event) {\n        if (this.enableEnterEvent) {\n            if (event.type === 'mouseenter') {\n                this._emit(ENTER_EVENT_TYPE, event);\n            }\n        }\n    }\n    handleLeaveEvent(event) {\n        if (this.enableLeaveEvent) {\n            if (event.type === 'mouseleave') {\n                this._emit(LEAVE_EVENT_TYPE, event);\n            }\n        }\n    }\n    handleMoveEvent(event) {\n        if (this.enableMoveEvent) {\n            switch (event.type) {\n                case 'mousedown':\n                    if (event.button >= 0) {\n                        // Button is down\n                        this.pressed = true;\n                    }\n                    break;\n                case 'mousemove':\n                    // Move events use `which` to track the button being pressed\n                    if (event.which === 0) {\n                        // Button is not down\n                        this.pressed = false;\n                    }\n                    if (!this.pressed) {\n                        // Drag events are emitted by hammer already\n                        // we just need to emit the move event on hover\n                        this._emit(MOVE_EVENT_TYPE, event);\n                    }\n                    break;\n                case 'mouseup':\n                    this.pressed = false;\n                    break;\n                default:\n            }\n        }\n    }\n    _emit(type, event) {\n        this.callback({\n            type,\n            center: {\n                x: event.clientX,\n                y: event.clientY\n            },\n            srcEvent: event,\n            pointerType: 'mouse',\n            target: event.target\n        });\n    }\n}\n//# sourceMappingURL=move-input.js.map"]},"metadata":{},"sourceType":"module"}